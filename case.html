<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç—…ä¾‹è¯¦æƒ… Â· KidneySphere</title>
  <meta name="description" content="KidneySphere Â· Case Detail">
  <link rel="icon" href="assets/logo.png" />
  <link rel="stylesheet" href="styles.css?v=20260213_001" />
</head>
<body class="page-case">
  <header class="nav">
    <div class="container nav-inner">
      <a class="brand" href="index.html" aria-label="KidneySphere Home">
        <img src="assets/logo.png" alt="KidneySphere AI Logo" />
        <div class="title">
          <b>è‚¾åŸŸAI Â· KidneySphereAI</b>
          <span>GlomConä¸­å›½ Ã— KidneySphere AI</span>
        </div>
      </a>

      <nav class="menu" aria-label="Primary">
        <a data-nav href="index.html"><span class="zh">é¦–é¡µ</span><span class="en">Home</span></a>
        <a data-nav href="community.html"><span class="zh">ç¤¾åŒºè®¨è®º</span><span class="en">Community</span></a>
        <a data-nav href="learning.html"><span class="zh">å­¦ä¹ ä¸­å¿ƒ</span><span class="en">Learning</span></a>
        <a data-nav href="frontier.html"><span class="zh">å‰æ²¿è¿›å±•</span><span class="en">Frontier</span></a>
        <a data-nav href="moments.html"><span class="zh">ç¤¾åŒºåŠ¨æ€</span><span class="en">Moments</span></a>
        <a data-nav href="events.html"><span class="zh">ä¼šè®®ä¸æ´»åŠ¨</span><span class="en">Events</span></a>
        <a data-nav href="research.html"><span class="zh">ä¸´åºŠç ”ç©¶ä¸­å¿ƒ</span><span class="en">Research</span></a>
        <a data-nav href="about.html"><span class="zh">å…³äº</span><span class="en">About</span></a>
      </nav>

      <div class="auth" data-auth>
        <a class="btn" href="login.html">ç™»å½•</a>
        <a class="btn primary" href="register.html">æ³¨å†Œ</a>
      </div>
    </div>
  </header>

  <main>
    <section class="hero">
      <div class="container">
        <div class="card">
          <div style="display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap;align-items:flex-start">
            <div style="min-width:0">
      <span class="badge" id="caseBadge">Case Â· ç—…ä¾‹</span>
              <h1 id="caseTitle" style="margin-top:10px">åŠ è½½ä¸­â€¦</h1>
              <div class="small muted" id="caseMeta" style="margin-top:6px"></div>
              <div id="caseTags" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px"></div>
              <div class="small" style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap">
                <button class="btn" id="likeBtn" type="button" title="ç»™è¿™ä¸ªå¸–å­ç‚¹ä¸ªèµï¼ˆç”¨äºè´¨é‡ç§¯åˆ†ï¼‰">ğŸ‘ èµ <span id="likeCount">0</span></button>
                <button class="btn" id="favBtn" type="button" title="æ”¶è—åˆ°æˆ‘çš„æ”¶è—åˆ—è¡¨">â­ æ”¶è—</button>
              </div>
            </div>
            <div style="display:flex;gap:10px;flex-wrap:wrap">
              <a class="btn" href="javascript:history.back()">è¿”å›</a>
              <button class="btn danger" id="deleteBtn" hidden>åˆ é™¤</button>
            </div>
          </div>

          <div class="hr"></div>
          <div id="caseBody">
            <p class="muted">æ­£åœ¨è¯»å–ç—…ä¾‹å†…å®¹â€¦</p>
          </div>

          <div id="caseAttachBlock" style="margin-top:12px"></div>

          <!-- AI Summary / Structured (Stage 1: Free AI + manual paste-back) -->
          <div id="aiSummaryBlock" style="margin-top:16px" hidden></div>
          <div id="aiStructuredBlock" style="margin-top:12px" hidden></div>
          <div id="aiToolsBlock" style="margin-top:12px" hidden></div>

          <div class="hr"></div>

          <div class="section-title">
            <div>
              <h3>è¯„è®ºä¸è®¨è®º</h3>
              <p>æ¡Œé¢ç«¯é»˜è®¤å±•å¼€ä¾¿äºé˜…è¯»ï¼›æ‰‹æœºç«¯å¯æŠ˜å æŸ¥çœ‹å…¨æ–‡ä¸é™„ä»¶ã€‚è¯·æ³¨æ„å»æ ‡è¯†åŒ–ä¸å­¦æœ¯è®¨è®ºè§„èŒƒã€‚</p>
            </div>
            <span class="badge">Reply</span>
          </div>

          <div id="commentList" class="case-thread" style="margin-top:12px"></div>

          <div class="hr"></div>

          <form id="commentForm" class="form">
            <label>å‘è¡¨å›å¤</label>
            <textarea class="input" id="commentBody" rows="4" placeholder="è¯·è¾“å…¥è¯„è®ºå†…å®¹ï¼ˆé¿å…åŒ…å«æ‚£è€…å§“åã€ä½é™¢å·ã€ç”µè¯ç­‰å¯è¯†åˆ«ä¿¡æ¯ï¼‰" required></textarea>

            <div class="attach-tools" style="margin-top:10px">
              <input id="caseAttachInput" type="file" multiple hidden accept="image/*,application/pdf,.pdf,.doc,.docx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
              <button class="btn tiny" type="button" id="casePickAttachBtn">ğŸ“ æ·»åŠ é™„ä»¶</button>
              <button class="btn tiny" type="button" id="caseClearAttachBtn">æ¸…ç©º</button>
              <span class="attach-hint">æ”¯æŒå›¾ç‰‡ / PDF / Wordï¼ˆå•ä¸ªâ‰¤20MBï¼Œæœ€å¤š 9 ä¸ªï¼›å¯ç›´æ¥æ‹–æ‹½/ç²˜è´´åˆ°è¾“å…¥æ¡†ï¼‰</span>
            </div>
            <div id="caseAttachPreview" class="attach-list"></div>

            <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center">
              <button class="btn tiny" type="button" id="commentMentionAuthor" title="@ç—…ä¾‹ä½œè€…">@ä½œè€…</button>
              <button class="btn tiny" type="button" id="commentMentionDoctor" title="@å…¶ä»–åŒ»ç”Ÿ">@åŒ»ç”Ÿ</button>
              <button class="btn primary" id="commentSubmit" type="submit">å‘å¸ƒå›å¤</button>
              <span class="small muted" id="commentHint"></span>
            </div>
          </form>

          <!-- Comment detail modal (thread-style reading) -->
          <div id="commentModal" class="modal" hidden>
            <div class="modal-panel">
              <div class="modal-head">
                <div style="min-width:0">
                  <b id="modalAuthor">æˆå‘˜</b>
                  <div class="small muted" id="modalWhen" style="margin-top:4px"></div>
                </div>
                <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
                  <button class="btn tiny" id="modalLikeBtn" type="button">ğŸ‘ ç‚¹èµ Â· 0</button>
                  <button class="btn tiny danger" id="modalDeleteBtn" hidden>åˆ é™¤</button>
                  <button class="modal-close" id="modalCloseBtn" type="button">å…³é—­</button>
                </div>
              </div>
              <div class="hr"></div>
              <div id="modalBody" class="ks-prose"></div>
              <div id="modalAttaches" style="margin-top:10px"></div>
            </div>
          </div>

        </div>
      </div>
    </section>
  </main>

  <div class="toast" data-toast></div>

  <footer class="footer">
    <div class="container footer-grid">
      <div>
        <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
          <img src="assets/logo.png" alt="logo" style="width:26px;height:26px;border-radius:8px">
          <b>KidneySphere Ã— KidneySphere AI</b>
        </div>
        <div class="small">ç—…ä¾‹å†…å®¹ä»…ä¾›å­¦æœ¯äº¤æµï¼›å‘å¸ƒå‰è¯·å®Œæˆå»æ ‡è¯†åŒ–å¤„ç†ã€‚</div>
      </div>
      <div class="small">
        <div>Â© 2025â€“2026 KidneySphere</div>
      </div>
    </div>
  </footer>

  <script type="module">
    import { supabase, isConfigured, toast, ensureAuthed, getCurrentUser, getUserProfile, isAdminRole, normalizeRole, formatBeijingDateTime } from './supabaseClient.js?v=20260128_030';
    import { pickDoctor, formatMention, insertAtCursor } from './mentionPicker.js?v=20260130_001';
    import { mountKSEditor } from './ks_editor.js?v=20260213_001';
    import { renderSafeHtml } from './ks_richtext.js?v=20260213_001';

    const qs = new URLSearchParams(location.search);
    const caseIdRaw = qs.get('id') || '';
    const caseId = Number(caseIdRaw);

    const titleEl = document.getElementById('caseTitle');
    const metaEl = document.getElementById('caseMeta');
    const tagsEl = document.getElementById('caseTags');
    const bodyEl = document.getElementById('caseBody');
	    const caseAttachBlock = document.getElementById('caseAttachBlock');
	    const aiSummaryBlock = document.getElementById('aiSummaryBlock');
	    const aiStructuredBlock = document.getElementById('aiStructuredBlock');
	    const aiToolsBlock = document.getElementById('aiToolsBlock');
    const listEl = document.getElementById('commentList');
    const delBtn = document.getElementById('deleteBtn');
    const likeBtn = document.getElementById('likeBtn');
    let likeCountEl = document.getElementById('likeCount');
    // æ”¶è—æŒ‰é’®ï¼ˆæ­¤å‰ç¼ºå°‘å£°æ˜ä¼šå¯¼è‡´æ¨¡å—è„šæœ¬æŠ¥é”™ï¼Œè¿›è€Œæ•´é¡µâ€œåŠ è½½ä¸­â€¦â€å¡æ­»ï¼‰
    const favBtn = document.getElementById('favBtn');

    const form = document.getElementById('commentForm');
    const bodyInput = document.getElementById('commentBody');
    const submitBtn = document.getElementById('commentSubmit');
    const hintEl = document.getElementById('commentHint');

    // Word-like rich editor for discussion replies (sync plain text back to textarea)
    const commentEditor = bodyInput ? mountKSEditor(bodyInput, {
      mode: 'comment',
      placeholder: 'å†™å›å¤â€¦ï¼ˆæ”¯æŒåŠ ç²—/é¢œè‰²/åˆ—è¡¨ï¼›ä» Word ç²˜è´´å¯è‡ªåŠ¨æ’ç‰ˆï¼‰',
      syncToTextarea: true,
    }) : null;
    const commentDropEl = commentEditor ? commentEditor.surface : bodyInput;
    const commentHoverEl = commentEditor ? commentEditor.root : bodyInput;
    const mentionAuthorBtn = document.getElementById('commentMentionAuthor');
    const mentionDoctorBtn = document.getElementById('commentMentionDoctor');

    // Attachments picker (for case comments)
    const attachInput = document.getElementById('caseAttachInput');
    const attachPickBtn = document.getElementById('casePickAttachBtn');
    const attachClearBtn = document.getElementById('caseClearAttachBtn');
    const attachPreview = document.getElementById('caseAttachPreview');

    // Thread-style modal (for reading a single comment)
    const modalEl = document.getElementById('commentModal');
    const modalAuthor = document.getElementById('modalAuthor');
    const modalWhen = document.getElementById('modalWhen');
    const modalLikeBtn = document.getElementById('modalLikeBtn');
    const modalBody = document.getElementById('modalBody');
    const modalAttaches = document.getElementById('modalAttaches');
    const modalCloseBtn = document.getElementById('modalCloseBtn');
    const modalDeleteBtn = document.getElementById('modalDeleteBtn');

    function esc(str){
      return String(str ?? '').replace(/[&<>"']/g, s => ({
        '&':'&amp;',
        '<':'&lt;',
        '>':'&gt;',
        '"':'&quot;',
        "'":'&#39;'
      }[s]));
    }

    // Render text with:
    // - escape HTML
    // - @mentions:
    //     - legacy: @[Name](uuid)
    //     - new: @Name (no uuid)
    // - auto-linkify URLs
    // - preserve newlines
    function renderRichText(str){
      const s = String(str ?? '');
      const tokenRe = /@\[([^\]]+?)\]\(([0-9a-fA-F-]{36})\)|(^|[\s(ï¼ˆã€\[{\u3000>ã€Šâ€œâ€˜'"ã€ï¼Œã€‚ï¼ï¼Ÿ;:])@([A-Za-z0-9_\-\u4e00-\u9fa5Â·]{1,24})|(?:https?:\/\/|www\.)[^\s<]+/gm;

      let out = '';
      let last = 0;
      for(const m of s.matchAll(tokenRe)){
        const start = m.index ?? 0;
        const full = String(m[0] ?? '');
        out += esc(s.slice(last, start));

        if(full.startsWith('@[')){
          const name = String(m[1] ?? '').trim() || 'åŒ»ç”Ÿ';
          const id = String(m[2] ?? '').trim();
          out += `<span class="mention" data-uid="${esc(id)}">@${esc(name)}</span>`;
          last = start + full.length;
          continue;
        }

        // Plain mention token (boundary + name)
        if(typeof m[4] === 'string' && m[4]){
          const prefix = String(m[3] ?? '');
          const name = String(m[4] ?? '').trim();
          if(prefix) out += esc(prefix);
          out += `<span class="mention">@${esc(name)}</span>`;
          last = start + full.length;
          continue;
        }

        // URL
        let rawUrl = full;
        let url = rawUrl;
        let trailing = '';
        while(url.length){
          const ch = url[url.length - 1];
          if(/[\)\]\}\.,!?;:ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€‹ã€ã€â€â€™"']/.test(ch)){
            trailing = ch + trailing;
            url = url.slice(0, -1);
            continue;
          }
          break;
        }
        const href = url.startsWith('www.') ? `https://${url}` : url;
        if(url){
          out += `<a class="auto-link" href="${esc(href)}" target="_blank" rel="noopener noreferrer">${esc(url)}</a>`;
        }else{
          out += esc(rawUrl);
        }
        if(trailing) out += esc(trailing);
        last = start + rawUrl.length;
      }
      out += esc(s.slice(last));
      return out.replace(/\n/g, '<br/>');
    }

    // Lightweight Markdown renderer for AI summary (safe, no raw HTML)
    // Supports: #/##/### headings, -/* bullet lists, numbered lists, bold **text**
    function renderMarkdownLite(md){
      const src = String(md ?? '').replace(/\r\n/g, '\n');
      const lines = src.split('\n');
      let html = '';
      let inUl = false;
      let inOl = false;

      const closeLists = ()=>{
        if(inUl){ html += '</ul>'; inUl = false; }
        if(inOl){ html += '</ol>'; inOl = false; }
      };

      const inline = (s)=>{
        // escape first
        let x = esc(s);
        // bold
        x = x.replace(/\*\*([^*]+)\*\*/g, '<b>$1</b>');
        // linkify URLs
        x = x.replace(/((?:https?:\/\/|www\.)[^\s<]+)/g, (m)=>{
          let url = m;
          let trailing = '';
          while(url.length){
            const ch = url[url.length - 1];
            if(/[\)\]\}\.,!?;:ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€‹ã€ã€â€â€™"']/.test(ch)){
              trailing = ch + trailing;
              url = url.slice(0, -1);
              continue;
            }
            break;
          }
          const href = url.startsWith('www.') ? `https://${url}` : url;
          const a = url ? `<a class="auto-link" href="${esc(href)}" target="_blank" rel="noopener noreferrer">${esc(url)}</a>` : esc(m);
          return a + esc(trailing);
        });
        return x;
      };

      for(const raw of lines){
        const line = String(raw ?? '');
        if(!line.trim()){
          closeLists();
          html += '<div style="height:10px"></div>';
          continue;
        }

        // Headings
        if(/^###\s+/.test(line)){
          closeLists();
          html += `<h4 style="margin:12px 0 6px">${inline(line.replace(/^###\s+/, ''))}</h4>`;
          continue;
        }
        if(/^##\s+/.test(line)){
          closeLists();
          html += `<h3 style="margin:14px 0 8px;font-size:18px">${inline(line.replace(/^##\s+/, ''))}</h3>`;
          continue;
        }
        if(/^#\s+/.test(line)){
          closeLists();
          html += `<h2 style="margin:16px 0 10px;font-size:20px">${inline(line.replace(/^#\s+/, ''))}</h2>`;
          continue;
        }

        // Bullet list
        if(/^\s*[-*]\s+/.test(line)){
          if(inOl){ html += '</ol>'; inOl = false; }
          if(!inUl){ html += '<ul style="margin:8px 0 8px 20px">'; inUl = true; }
          html += `<li style="margin:4px 0">${inline(line.replace(/^\s*[-*]\s+/, ''))}</li>`;
          continue;
        }

        // Numbered list
        if(/^\s*\d+[\.|ã€]\s+/.test(line)){
          if(inUl){ html += '</ul>'; inUl = false; }
          if(!inOl){ html += '<ol style="margin:8px 0 8px 22px">'; inOl = true; }
          html += `<li style="margin:4px 0">${inline(line.replace(/^\s*\d+[\.|ã€]\s+/, ''))}</li>`;
          continue;
        }

        closeLists();
        html += `<div style="line-height:1.8;margin:4px 0">${inline(line)}</div>`;
      }
      closeLists();
      return html;
    }

    function detectPrivacyFlags(text){
      const s = String(text || '');
      const flags = [];
      // Mainland China mobile numbers
      if(/(?:\+?86)?1[3-9]\d{9}/.test(s)) flags.push('ç–‘ä¼¼æ‰‹æœºå·');
      // PRC ID number (rough)
      if(/\b\d{17}[0-9Xx]\b/.test(s)) flags.push('ç–‘ä¼¼èº«ä»½è¯å·');
      // Hospitalization number keywords
      if(/(ä½é™¢å·|é—¨è¯Šå·|ç—…æ¡ˆå·|å°±è¯Šå·|ID[:ï¼š]?)/i.test(s)) flags.push('ç–‘ä¼¼å°±è¯Š/ä½é™¢ç¼–å·');
      return flags;
    }

    async function copyText(text){
      const t = String(text || '');
      if(!t.trim()) return false;
      try{
        await navigator.clipboard.writeText(t);
        return true;
      }catch(_e){
        try{
          const ta = document.createElement('textarea');
          ta.value = t;
          ta.style.position = 'fixed';
          ta.style.top = '-1000px';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          return ok;
        }catch(_e2){
          return false;
        }
      }
    }

    function tagChip(t){
      return `<span class="badge" style="border-color:rgba(255,255,255,.14);background:rgba(255,255,255,.06)">${esc(t)}</span>`;
    }

    // ------------------------------------------------------------
    // Attachments (case_comment)
    // ------------------------------------------------------------
    const MAX_ATTACH_BYTES = 20 * 1024 * 1024; // 20MB per file
    const MAX_ATTACH_COUNT = 9;
    let attachPicks = []; // { file, id, url? }

    function fmtSize(n){
      const b = Number(n || 0);
      if(!Number.isFinite(b) || b <= 0) return '';
      const kb = b / 1024;
      if(kb < 1024) return `${Math.round(kb)}KB`;
      const mb = kb / 1024;
      if(mb < 1024) return `${mb.toFixed(1)}MB`;
      const gb = mb / 1024;
      return `${gb.toFixed(2)}GB`;
    }

    function guessKindFromMime(mime, name){
      const t = String(mime || '').toLowerCase();
      const n = String(name || '').toLowerCase();
      if(t.startsWith('image/')) return 'image';
      if(t.includes('pdf') || n.endsWith('.pdf')) return 'pdf';
      if(t.includes('msword') || t.includes('wordprocessingml') || n.endsWith('.doc') || n.endsWith('.docx')) return 'doc';
      return 'file';
    }

    function safeFilename(name){
      // Supabase Storage object keys should be URL-safe (ASCII). Non-ASCII characters
      // (e.g. Chinese) can trigger "Invalid key" errors in supabase-js.
      const raw = String(name || 'file').trim();
      const dot = raw.lastIndexOf('.');
      const stemRaw = dot > 0 ? raw.slice(0, dot) : raw;
      const extRaw = dot > 0 && dot < raw.length - 1 ? raw.slice(dot + 1) : '';

      let stem = stemRaw
        .normalize ? stemRaw.normalize('NFKD') : stemRaw;
      stem = stem
        .replace(/\s+/g, '_')
        .replace(/[^a-zA-Z0-9_-]/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_+|_+$/g, '')
        .slice(0, 60);
      if(!stem) stem = 'file';

      let ext = String(extRaw || '').toLowerCase().replace(/[^a-z0-9]/g, '').slice(0, 10);
      return ext ? `${stem}.${ext}` : stem;
    }

    function renderAttachDraft(){
      if(!attachPreview) return;
      if(!attachPicks.length){
        attachPreview.innerHTML = '';
        if(attachClearBtn) attachClearBtn.disabled = true;
        return;
      }
      if(attachClearBtn) attachClearBtn.disabled = false;
      attachPreview.innerHTML = attachPicks.map(p=>{
        const file = p.file;
        const kind = guessKindFromMime(file?.type, file?.name);
        const icon = kind === 'image' ? 'ğŸ–¼ï¸' : (kind === 'pdf' ? 'ğŸ“„' : (kind === 'doc' ? 'ğŸ“' : 'ğŸ“'));
        return `
          <div class="attach-item" data-attach-item="${p.id}">
            <div class="left">
              <div class="name">${icon} ${esc(file?.name || 'é™„ä»¶')}</div>
              <div class="meta">${esc(String(file?.type || ''))}${file?.size ? ' Â· ' + fmtSize(file.size) : ''}</div>
            </div>
            <button class="btn tiny" type="button" data-attach-remove="${p.id}">ç§»é™¤</button>
          </div>
        `;
      }).join('');
    }

    function addAttachFiles(files){
      const list = Array.from(files || []);
      if(!list.length) return;
      const next = [...attachPicks];
      for(const f of list){
        if(next.length >= MAX_ATTACH_COUNT) break;
        if((f.size || 0) > MAX_ATTACH_BYTES){
          const mb = Math.round((f.size || 0) / 1024 / 1024);
          toast('é™„ä»¶è¿‡å¤§', `${f.name}ï¼ˆ${mb}MBï¼‰è¶…å‡ºé™åˆ¶ï¼ˆå•ä¸ªâ‰¤${Math.round(MAX_ATTACH_BYTES/1024/1024)}MBï¼‰ã€‚`, 'err');
          continue;
        }
        next.push({ file: f, id: `${Date.now()}_${Math.random().toString(16).slice(2)}` });
      }
      attachPicks = next;
      renderAttachDraft();
    }

    function clearAttachDraft(){
      attachPicks = [];
      if(attachInput) attachInput.value = '';
      renderAttachDraft();
    }

    // ------------------------------------------------------------
    // Thread-style comment list + modal
    // ------------------------------------------------------------
    let commentRows = [];
    let attachmentsByComment = new Map();
    let openCommentId = null;
    let commentLikeSupported = true;
    let likedCommentIds = new Set();

    function snip(text, max=140){
      const s = String(text || '').replace(/\s+/g, ' ').trim();
      if(s.length <= max) return s;
      return s.slice(0, max) + 'â€¦';
    }

    function isMobileViewport(){
      return window.matchMedia('(max-width: 860px)').matches;
    }

    function initials(name){
      const s = String(name || '').trim();
      if(!s) return 'KS';
      const chars = Array.from(s.replace(/\s+/g, ''));
      // Chinese names: 2 chars; English: take 2 initials
      if(/[\u4E00-\u9FFF]/.test(chars.join(''))){
        return chars.slice(0, 2).join('');
      }
      const parts = s.split(/\s+/g).filter(Boolean);
      const pick = (parts[0]?.[0] || '') + (parts[1]?.[0] || parts[0]?.[1] || '');
      return (pick || s.slice(0, 2)).toUpperCase();
    }

    // Attachments renderer
    // - Images: show as a grid of thumbnails
    // - Files: show as chips
    // - PDF (desktop): additionally show an inline first-page preview thumbnail (best-effort)
    function renderAttachmentsBlock(attaches, opts={}){
      const raw = Array.isArray(attaches) ? attaches : [];
      if(!raw.length) return '';

      // Only render links we can actually open. For private buckets, URLs are resolved
      // via signed URLs at load time; anonymous users may not have access.
      const a = raw.filter(x => x && String(x.public_url || '').trim().length > 0);
      if(!a.length){
        return '<div class="small muted">ï¼ˆé™„ä»¶ä»…ç™»å½•åå¯æŸ¥çœ‹ï¼‰</div>';
      }

      const thumbPdf = Boolean(opts.thumbPdf);
      const imgs = a.filter(x => String(x.kind || '') === 'image');
      const files = a.filter(x => String(x.kind || '') !== 'image');
      const pdfs = files.filter(x => String(x.kind || '') === 'pdf');

      const imgHtml = imgs.length ? `
        <div class="attach-grid">
          ${imgs.map(x=>`<a class="attach-img" href="${esc(x.public_url || '')}" target="_blank" rel="noopener"><img alt="img" src="${esc(x.public_url || '')}"/></a>`).join('')}
        </div>
      ` : '';

      // PDF first-page preview (desktop best-effort). We keep file chips as the reliable open/download.
      const pdfThumbHtml = (thumbPdf && pdfs.length) ? `
        <div class="pdf-grid" aria-label="PDF previews">
          ${pdfs.map(x=>{
            const url = String(x.public_url || '');
            const nm = x.original_name || x.path || 'PDF';
            const src = url ? `${url}#page=1&view=FitH` : '';
            return `
              <a class="pdf-card" href="${esc(url)}" target="_blank" rel="noopener">
                <div class="pdf-frame">${src ? `<iframe loading="lazy" src="${esc(src)}" title="${esc(nm)}"></iframe>` : ''}</div>
                <div class="pdf-cap">ğŸ“„ ${esc(nm)}</div>
              </a>
            `;
          }).join('')}
        </div>
      ` : '';

      const fileHtml = files.length ? `
        <div class="attach-list">
          ${files.map(x=>{
            const icon = String(x.kind || '') === 'pdf' ? 'ğŸ“„' : (String(x.kind || '') === 'doc' ? 'ğŸ“' : 'ğŸ“');
            const nm = x.original_name || x.path || 'é™„ä»¶';
            return `<a class="file-chip" href="${esc(x.public_url || '')}" target="_blank" rel="noopener">${icon} ${esc(nm)}</a>`;
          }).join('')}
        </div>
      ` : '';

      return imgHtml + pdfThumbHtml + fileHtml;
    }



    const ATTACH_SIGN_TTL_SECONDS = 60 * 60; // 1 hour

    async function hydrateSignedUrlsForAttachments(attRows){
      const rows = Array.isArray(attRows) ? attRows : [];
      if(!rows.length) return;

      const need = rows.filter(a => a && String(a.bucket || 'attachments') === 'attachments' && a.path);
      if(!need.length) return;

      // Case pages are authenticated, but keep it defensive.
      if(!currentUser){
        for(const a of need){ a.public_url = ''; }
        return;
      }

      const bucket = 'attachments';
      const uniq = Array.from(new Set(need.map(a => String(a.path))));
      try{
        const api = supabase?.storage?.from(bucket);
        if(!api) return;

        if(typeof api.createSignedUrls === 'function'){
          const { data, error } = await api.createSignedUrls(uniq, ATTACH_SIGN_TTL_SECONDS);
          if(error) throw error;
          const map = new Map((data || []).map(x => [String(x.path), String(x.signedUrl || '')]));
          for(const a of need){
            const u = map.get(String(a.path));
            if(u) a.public_url = u;
          }
          return;
        }

        if(typeof api.createSignedUrl === 'function'){
          for(const a of need){
            try{
              const { data, error } = await api.createSignedUrl(String(a.path), ATTACH_SIGN_TTL_SECONDS);
              if(!error && data?.signedUrl) a.public_url = data.signedUrl;
            }catch(_e){ /* ignore */ }
          }
        }
      }catch(_e){
        // If signing fails, clear legacy public URLs (they won't work once bucket is private).
        for(const a of need){
          const u = String(a.public_url || '');
          if(!u || u.includes('/storage/v1/object/public/attachments/')) a.public_url = '';
        }
      }
    }

    // Load attachments attached to the case itself (target_type = 'case')
    async function loadCaseAttachments(){
      if(!caseAttachBlock) return;
      if(!currentCase) { caseAttachmentRows = []; caseAttachBlock.innerHTML = ''; return; }

      try{
        const { data, error } = await supabase
          .from('attachments')
          .select('id, target_type, target_id, kind, bucket, path, public_url, original_name, created_at')
          .eq('target_type', 'case')
          .eq('target_id', Number(currentCase.id))
          .is('deleted_at', null)
          .order('created_at', { ascending: true });
        if(error) throw error;

        const rows = data || [];
        await hydrateSignedUrlsForAttachments(rows);
        caseAttachmentRows = rows;
        if(!rows.length){
          caseAttachBlock.innerHTML = '';
          return;
        }

        caseAttachBlock.innerHTML = `<div class="small muted" style="margin-bottom:8px"><b>ç—…ä¾‹é™„ä»¶</b></div>` + renderAttachmentsBlock(rows, { thumbPdf: !isMobileViewport() });
      }catch(_e){
        // attachments table may not exist on some environments; fail silently
        caseAttachmentRows = [];
        caseAttachBlock.innerHTML = '';
      }
    }

    function commentActionsHtml(c, canDelete){
      const likeCount = Number(c.like_count || 0);
      const isLiked = likedCommentIds && typeof likedCommentIds.has === 'function' ? likedCommentIds.has(String(c.id)) : false;
      const likeText = isLiked ? `ğŸ’™ å·²èµ Â· ${likeCount}` : `ğŸ‘ ç‚¹èµ Â· ${likeCount}`;
      const likeBtnHtml = commentLikeSupported
        ? `<button class="btn tiny ${isLiked ? 'primary' : ''}" type="button" data-like-comment="${c.id}" data-liked="${isLiked ? '1' : '0'}" data-count="${likeCount}">${likeText}</button>`
        : `<span class="small muted">ğŸ‘ ${likeCount}</span>`;
      const replyBtn = `<button class="btn tiny" type="button" data-reply-comment="${c.id}">å›å¤</button>`;
      const delBtn = canDelete ? `<button class="btn tiny danger" type="button" data-del-comment="${c.id}">åˆ é™¤</button>` : '';
      return `${likeBtnHtml}${replyBtn}${delBtn}`;
    }

    function commentCardDesktop(c, canDelete){
      const when = c.created_at ? formatBeijingDateTime(c.created_at) : '';
      const attaches = attachmentsByComment.get(String(c.id)) || [];
      const attachBlock = attaches.length ? `<div class="msg-attaches">${renderAttachmentsBlock(attaches, { thumbPdf: true })}</div>` : '';
      const isMod = !!(moderatorIds && moderatorIds.has(String(c.author_id)));
      const modBadge = isMod ? `<span class="badge mod mini" style="margin-left:6px">ç‰ˆä¸»</span>` : '';
      const bHtml = String(c.body_html || '').trim();
      const renderedBody = bHtml ? renderSafeHtml(bHtml, { mode:'comment', linkify:true, mentionify:true }) : renderRichText(String(c.body || ''));
      return `
        <article id="comment-${c.id}" class="msg msg-desktop" data-comment-id="${c.id}">
          <div class="msg-left">
            <div class="msg-avatar" aria-hidden="true">${esc(initials(c.author_name || 'Member'))}</div>
          </div>
          <div class="msg-content">
            <div class="msg-head">
              <div class="msg-meta">
                <b class="msg-author">${esc(c.author_name || 'Member')}</b>${modBadge}
                <span class="msg-when">${esc(when)}</span>
              </div>
              <div class="msg-actions">${commentActionsHtml(c, canDelete)}</div>
            </div>
            <div class="msg-body ks-prose">${renderedBody}</div>
            ${attachBlock}
          </div>
        </article>
      `;
    }

    function commentCardMobile(c, canDelete){
      const when = c.created_at ? formatBeijingDateTime(c.created_at) : '';
      const attaches = attachmentsByComment.get(String(c.id)) || [];
      const likeCount = Number(c.like_count || 0);
      const hint = `ğŸ‘ ${likeCount}${attaches.length ? ` Â· ğŸ“ ${attaches.length}` : ''}`;
      const attachBlock = attaches.length ? `<div class="msg-attaches">${renderAttachmentsBlock(attaches, { thumbPdf: false })}</div>` : '';
      const isMod = !!(moderatorIds && moderatorIds.has(String(c.author_id)));
      const modBadge = isMod ? `<span class="badge mod mini" style="margin-left:6px">ç‰ˆä¸»</span>` : '';
      const bHtml = String(c.body_html || '').trim();
      const renderedBody = bHtml ? renderSafeHtml(bHtml, { mode:'comment', linkify:true, mentionify:true }) : renderRichText(String(c.body || ''));
      return `
        <details id="comment-${c.id}" class="msg msg-mobile" data-comment-id="${c.id}">
          <summary class="msg-summary">
            <div class="msg-s-top">
              <div class="msg-left"><div class="msg-avatar" aria-hidden="true">${esc(initials(c.author_name || 'M'))}</div></div>
              <div class="msg-s-main">
                <div class="msg-meta">
                  <b class="msg-author">${esc(c.author_name || 'Member')}</b>${modBadge}
                  <span class="msg-when">${esc(when)}</span>
                </div>
                <div class="msg-snippet">${esc(snip(c.body || '', 120))}</div>
                <div class="small muted" data-like-hint="${c.id}" style="margin-top:6px">${esc(hint)}</div>
              </div>
              <div class="msg-chevron" aria-hidden="true">â–¾</div>
            </div>
          </summary>
          <div class="msg-detail">
            <div class="msg-actions">${commentActionsHtml(c, canDelete)}</div>
            <div class="msg-body ks-prose">${renderedBody}</div>
            ${attachBlock}
          </div>
        </details>
      `;
    }

    function scrollToCommentFromHash(){
      const h = String(location.hash || '');
      if(!h || !h.startsWith('#comment-')) return;
      const el = document.querySelector(h);
      if(!el) return;
      try{
        if(el.tagName === 'DETAILS') el.open = true;
        el.classList.add('highlight');
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        setTimeout(()=>el.classList.remove('highlight'), 2600);
      }catch(_e){}
    }

    window.addEventListener('hashchange', ()=>setTimeout(scrollToCommentFromHash, 50));

    function renderCommentList(){
      if(!listEl) return;
      const rows = Array.isArray(commentRows) ? commentRows : [];
      if(!rows.length){
        listEl.innerHTML = '<div class="muted small">æš‚æ— è¯„è®ºã€‚æ¬¢è¿å‘è¡¨ç¬¬ä¸€æ¡å›å¤ã€‚</div>';
        return;
      }
      const uid = currentUser?.id || '';
      const canModerate = Boolean(
        isAdminUi
        || isModeratorUser
        || isBoardModeratorUser
        || (uid && currentCase && String(currentCase.author_id) === String(uid))
      );
      const mobile = isMobileViewport();
      listEl.innerHTML = rows.map(c => {
        const canDelete = Boolean(
          canModerate
          || (uid && String(c.author_id) === String(uid))
        );
        return mobile ? commentCardMobile(c, canDelete) : commentCardDesktop(c, canDelete);
      }).join('');

      // If the URL has #comment-xxx (e.g., fromé€šçŸ¥ä¸­å¿ƒ/çº¢ç‚¹è·³è½¬), scroll to it.
      setTimeout(scrollToCommentFromHash, 60);
    }

    function replyToComment(commentId){
      const id = Number(commentId);
      const c = commentRows.find(r => Number(r.id) === id);
      if(!c) return;
      const name = c.author_name || 'Member';
      const uid = String(c.author_id || '').trim();
      // Best-effort mention format if we have author_id (uuid)
      try{
        if(uid && /^[0-9a-fA-F-]{36}$/.test(uid)){
          insertAtCursor(bodyInput, formatMention({ id: uid, full_name: name }) + ' ');
        }else{
          insertAtCursor(bodyInput, '@' + name + ' ');
        }
      }catch(_e){
        bodyInput.value = (bodyInput.value || '') + '\n@' + name + ' ';
      }
      bodyInput?.focus?.();
      try{ form?.scrollIntoView?.({ behavior: 'smooth', block: 'center' }); }catch(_e){}
    }

    // Re-render on viewport breakpoint changes (e.g., rotate phone)
    let _lastMobile = null;
    function _syncCommentLayout(){
      const m = isMobileViewport();
      if(_lastMobile === null) _lastMobile = m;
      if(m !== _lastMobile){
        _lastMobile = m;
        renderCommentList();
      }
    }
    window.addEventListener('resize', ()=>{
      // Light debounce
      clearTimeout(window.__ks_case_resize_t);
      window.__ks_case_resize_t = setTimeout(_syncCommentLayout, 120);
    });

    function setLoading(){
      titleEl.textContent = 'åŠ è½½ä¸­â€¦';
      metaEl.textContent = '';
      tagsEl.innerHTML = '';
      bodyEl.innerHTML = '<p class="muted">æ­£åœ¨è¯»å–ç—…ä¾‹å†…å®¹â€¦</p>';
      listEl.innerHTML = '<div class="muted small">åŠ è½½è¯„è®ºä¸­â€¦</div>';
      if(aiSummaryBlock) aiSummaryBlock.innerHTML = '';
      if(aiStructuredBlock) aiStructuredBlock.innerHTML = '';
      if(aiToolsBlock){ aiToolsBlock.innerHTML = ''; aiToolsBlock.hidden = true; }
    }

    function setError(msg){
      titleEl.textContent = 'æ— æ³•åŠ è½½';
      bodyEl.innerHTML = `<div class="note"><b>æç¤ºï¼š</b>${esc(msg)}</div>`;
      listEl.innerHTML = '';
      if(aiSummaryBlock) aiSummaryBlock.innerHTML = '';
      if(aiStructuredBlock) aiStructuredBlock.innerHTML = '';
      if(aiToolsBlock){ aiToolsBlock.innerHTML = ''; aiToolsBlock.hidden = true; }
    }

    let currentUser = null;
    let currentProfile = null;
    let isAdminUser = false;
    let isAdminUi = false;
    // Extra moderation roles (not full admin UI)
    let isModeratorUser = false;       // profiles.role === 'moderator'
    let isBoardModeratorUser = false;  // in board_moderators for current case board
    let currentCase = null;
    let canPostCaseComments = true;

    // Per-board moderators (for "ç‰ˆä¸»" badge)
    let moderatorIds = new Set();

    async function loadBoardModerators(boardKey){
      moderatorIds = new Set();
      const bk = String(boardKey || '').toLowerCase();
      if(!bk) return;
      if(!isConfigured() || !supabase) return;
      try{
        const { data, error } = await supabase
          .from('board_moderators')
          .select('user_id')
          .eq('board_key', bk);
        if(error) throw error;
        moderatorIds = new Set((data || []).map(r => r.user_id));
      }catch(e){
        const msg = String(e && e.message ? e.message : e || '');
        // If table not created yet, silently ignore
        if(/board_moderators/i.test(msg) && /(does not exist|relation|schema cache|not find|could not find)/i.test(msg)) return;
      }
    }

    // AI features are paused (Stage 1 removed per product decision)
    const ENABLE_AI_FEATURES = false;

    function applyDoctorGateUI(){
      if(canPostCaseComments) return;
      const next = encodeURIComponent((location.pathname.split('/').pop() || 'case.html') + location.search);
      const href = `verify-doctor.html?next=${next}`;
      // Append a clear callout without overwriting existing hint text.
      hintEl.innerHTML = `${hintEl.innerHTML}<div style="margin-top:8px"><b>åŒ»ç”Ÿè®¤è¯æç¤ºï¼š</b>å›å¤ç—…ä¾‹è®¨è®º/ä¸Šä¼ é™„ä»¶éœ€è¦å®ŒæˆåŒ»ç”Ÿè®¤è¯ï¼ˆé‚€è¯·ç å¿«é€Ÿè®¤è¯æˆ–äººå·¥å®¡æ ¸ï¼‰ã€‚ <a class="btn tiny" href="${href}">å»è®¤è¯</a></div>`;

      // Disable submit + attachment UI
      try{
        submitBtn.disabled = true;
        attachPickBtn.disabled = true;
        attachClearBtn.disabled = true;
        attachInput.disabled = true;
        mentionAuthorBtn.disabled = true;
        mentionDoctorBtn.disabled = true;
        textarea.placeholder = 'å›å¤åŠŸèƒ½éœ€å…ˆå®ŒæˆåŒ»ç”Ÿè®¤è¯';
      }catch(_e){}
    }

    // Attachments on the case itself (loaded from attachments table)
    let caseAttachmentRows = [];

    // AI artifacts (Stage 1: generated externally, pasted back and saved)
    let aiSummaryRow = null;      // kind: summary_md
    let aiStructuredRow = null;   // kind: structured_json
    let aiSourceHashNow = '';
    let aiArtifactsSupported = true;
    let liked = false;
    let likeSupported = true;
    // æ”¶è—çŠ¶æ€ï¼ˆcase_favoritesï¼‰
    let faved = false;
    let favSupported = true;
    // NOTE: Keep like state simple and avoid duplicate declarations.
    // The actual like feature is implemented below (updateLikeBtn + loadLikeState).

    // ------------------------------------------------------------
    // AI Artifacts (Stage 1: Free AI + manual paste-back)
    // ------------------------------------------------------------
    function roleLower(){
      return String(normalizeRole(currentProfile?.role) || '').toLowerCase();
    }

    function canEditAi(){
      if(!currentUser || !currentCase) return false;
      const r = roleLower();
      const isAdmin = isAdminRole(r);
      const isDoctorVerified = (r === 'doctor_verified');
      const isAuthor = String(currentCase.author_id) === String(currentUser.id);
      // Stage 1: allow case author + doctor_verified + admin/super_admin
      return Boolean(isAdmin || isDoctorVerified || isAuthor);
    }

    function maxIso(a, b){
      if(!a) return b || '';
      if(!b) return a || '';
      try{
        return (new Date(a).getTime() >= new Date(b).getTime()) ? a : b;
      }catch(_e){
        return a || b || '';
      }
    }

    // Tiny non-crypto hash for change detection (FNV-1a 32bit)
    function fastHash(s){
      const str = String(s ?? '');
      let h = 2166136261;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = (h * 16777619) >>> 0;
      }
      return h.toString(36);
    }

    function computeAiSourceHash(){
      if(!currentCase) return '';
      // cases table does not always have updated_at; include a lightweight hash of title/summary/content
      const caseBaseTime = currentCase.updated_at || currentCase.created_at || '';
      const caseText = `${currentCase.title || ''}\n${currentCase.summary || ''}\n${currentCase.content || ''}`;
      const caseTextHash = fastHash(caseText.slice(0, 40000));
      const caseUpdated = `${caseBaseTime}#${caseTextHash}`;
      let lastComment = '';
      for(const c of (commentRows || [])){
        if(c?.deleted_at) continue;
        lastComment = maxIso(lastComment, c.created_at);
      }
      let lastAttach = '';
      for(const a of (caseAttachmentRows || [])){
        lastAttach = maxIso(lastAttach, a.created_at);
      }
      for(const arr of (attachmentsByComment?.values?.() || [])){
        for(const a of (arr || [])){
          lastAttach = maxIso(lastAttach, a.created_at);
        }
      }
      // Keep it deterministic and human-readable (no crypto needed)
      return `${caseUpdated}|${lastComment}|${lastAttach}`;
    }

    function aiHumanUpdatedAt(row){
      const t = row?.updated_at || row?.created_at;
      return t ? formatBeijingDateTime(t) : '';
    }

    function aiStale(row){
      const sig = aiSourceHashNow || '';
      const saved = String(row?.source_hash || '');
      if(!sig || !saved) return false;
      return sig !== saved;
    }

    function renderAiSummary(){
      if(!aiSummaryBlock) return;

      if(!aiArtifactsSupported){
        aiSummaryBlock.innerHTML = '';
        return;
      }

      const row = aiSummaryRow;
      const canEdit = canEditAi();

      if(!row){
        aiSummaryBlock.innerHTML = `
          <div class="note">
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;flex-wrap:wrap">
              <div>
                <b>è®¨è®ºæ‘˜è¦ï¼ˆäººå·¥ç¡®è®¤ï¼‰</b>
                <div class="small muted" style="margin-top:6px">å½“å‰æš‚æ— æ‘˜è¦ã€‚å»ºè®®ä½¿ç”¨ä¸‹æ–¹ <b>AI æ•´ç†å·¥å…·ï¼ˆå…è´¹ï¼‰</b> ç”Ÿæˆåç²˜è´´ä¿å­˜ã€‚</div>
              </div>
              <span class="badge">AI Summary</span>
            </div>
          </div>
        `;
        return;
      }

      const stale = aiStale(row);
      const badge = stale ? '<span class="badge" style="border-color:rgba(245,158,11,.35);background:rgba(245,158,11,.08)">å¾…æ›´æ–°</span>' : '<span class="badge">AI Summary</span>';
      const meta = `æ•´ç†ï¼š${esc(row?.creator_name || row?.created_by_name || row?.created_by || 'æˆå‘˜')} Â· ${esc(aiHumanUpdatedAt(row))}${stale ? ' Â· <b style="color:#b45309">è®¨è®ºå·²æ›´æ–°</b>' : ''}`;
      const content = String(row?.content_md || '').trim();

      aiSummaryBlock.innerHTML = `
        <div class="note">
          <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;flex-wrap:wrap">
            <div>
              <b>è®¨è®ºæ‘˜è¦ï¼ˆäººå·¥ç¡®è®¤ï¼‰</b>
              <div class="small muted" style="margin-top:6px">${meta}</div>
            </div>
            ${badge}
          </div>
          <div style="margin-top:12px;line-height:1.8">${renderMarkdownLite(content)}</div>
          ${stale ? `<div class="small" style="margin-top:10px;color:#b45309">æç¤ºï¼šè¯„è®ºæˆ–é™„ä»¶æœ‰æ›´æ–°ï¼Œå»ºè®®é‡æ–°ç”Ÿæˆå¹¶ä¿å­˜æ‘˜è¦ã€‚</div>` : ''}
        </div>
      `;
    }

    function renderAiStructured(){
      if(!aiStructuredBlock) return;
      if(!aiArtifactsSupported){
        aiStructuredBlock.innerHTML = '';
        return;
      }
      const row = aiStructuredRow;
      if(!row){
        aiStructuredBlock.innerHTML = '';
        return;
      }

      const stale = aiStale(row);
      const badge = stale ? '<span class="badge" style="border-color:rgba(245,158,11,.35);background:rgba(245,158,11,.08)">å¾…æ›´æ–°</span>' : '<span class="badge">Structured</span>';
      const meta = `æ•´ç†ï¼š${esc(row?.creator_name || row?.created_by_name || row?.created_by || 'æˆå‘˜')} Â· ${esc(aiHumanUpdatedAt(row))}${stale ? ' Â· <b style="color:#b45309">è®¨è®ºå·²æ›´æ–°</b>' : ''}`;
      let obj = row?.content_json;
      if(typeof obj === 'string'){
        try{ obj = JSON.parse(obj); }catch(_e){ obj = null; }
      }

      const safeVal = (v)=>{
        if(v === null || v === undefined) return '';
        if(typeof v === 'string') return v;
        if(typeof v === 'number' || typeof v === 'boolean') return String(v);
        return JSON.stringify(v);
      };

      const demographics = obj?.demographics || {};
      const presentation = obj?.presentation || {};
      const labs = obj?.key_labs || {};
      const pathology = obj?.pathology || {};
      const followup = obj?.followup || {};
      const points = Array.isArray(obj?.discussion_points) ? obj.discussion_points : [];
      const opens = Array.isArray(obj?.open_questions) ? obj.open_questions : [];
      const treatments = Array.isArray(obj?.treatments) ? obj.treatments : [];

      const kv = (k, v)=>{
        const val = safeVal(v);
        if(!val) return '';
        return `<div style="margin:2px 0"><span class="small muted">${esc(k)}ï¼š</span><span>${esc(val)}</span></div>`;
      };

      const section = (title, inner)=>{
        if(!inner) return '';
        return `
          <div style="margin-top:10px">
            <div class="small muted" style="margin-bottom:6px"><b>${esc(title)}</b></div>
            <div style="padding-left:2px">${inner}</div>
          </div>
        `;
      };

      const treatHtml = treatments.length ? `
        <ol style="margin:6px 0 0 18px">
          ${treatments.map(t=>{
            const s = [t?.date_or_phase, t?.meds, t?.dose, t?.response].filter(Boolean).join('ï½œ');
            return `<li style="margin:4px 0">${esc(s)}</li>`;
          }).join('')}
        </ol>
      ` : '';

      const pointsHtml = points.length ? `<ul style="margin:6px 0 0 18px">${points.map(x=>`<li style="margin:4px 0">${esc(String(x))}</li>`).join('')}</ul>` : '';
      const opensHtml = opens.length ? `<ul style="margin:6px 0 0 18px">${opens.map(x=>`<li style="margin:4px 0">${esc(String(x))}</li>`).join('')}</ul>` : '';

      const inner = [
        section('åŸºæœ¬ä¿¡æ¯', kv('æ€§åˆ«', demographics.sex) + kv('å¹´é¾„', demographics.age)),
        section('ä¸»è¯‰ä¸ç—…ç¨‹', kv('ä¸»è¯‰', presentation.chief_complaint) + kv('ç—…ç¨‹æ¦‚è¿°', presentation.course_summary)),
        section('å…³é”®åŒ–éªŒ', kv('Scr', labs.scr) + kv('eGFR', labs.egfr) + kv('è›‹ç™½å°¿', labs.proteinuria) + kv('ç™½è›‹ç™½', labs.albumin) + kv('PLA2R', labs.pla2r) + kv('è¡¥ä½“', labs.complements) + kv('å…¶ä»–', labs.other)),
        section('ç—…ç†è¦ç‚¹', kv('è¦ç‚¹', pathology.key_findings)),
        section('æ²»ç–—ä¸è°ƒæ•´', treatHtml),
        section('éšè®¿/ç»“å±€', kv('ç»“å±€', followup.outcomes)),
        section('è®¨è®ºè¦ç‚¹', pointsHtml),
        section('æœªè§£é—®é¢˜', opensHtml),
      ].join('');

      aiStructuredBlock.innerHTML = `
        <div class="note">
          <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;flex-wrap:wrap">
            <div>
              <b>ç»“æ„åŒ–è¦ç‚¹ï¼ˆäººå·¥ç¡®è®¤ï¼‰</b>
              <div class="small muted" style="margin-top:6px">${meta}</div>
            </div>
            ${badge}
          </div>
          <div style="margin-top:10px">${inner || '<div class="small muted">ï¼ˆç»“æ„åŒ–å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼ä¸å®Œæ•´ï¼‰</div>'}</div>
          ${stale ? `<div class="small" style="margin-top:10px;color:#b45309">æç¤ºï¼šè¯„è®ºæˆ–é™„ä»¶æœ‰æ›´æ–°ï¼Œå»ºè®®é‡æ–°ç”Ÿæˆå¹¶ä¿å­˜ç»“æ„åŒ–è¦ç‚¹ã€‚</div>` : ''}
        </div>
      `;
    }

    function buildAiContextText({ includeAttachments=true, maxComments=30 }={}){
      if(!currentCase) return '';
      const board = String(currentCase.board || '').toLowerCase();
      const boardName = (board === 'research') ? 'ç§‘ç ”è®¨è®º' : (board === 'literature' ? 'æ–‡çŒ®å­¦ä¹ ' : 'ç—…ä¾‹è®¨è®º');
      const lines = [];
      lines.push(`ã€ç—…ä¾‹æ ‡é¢˜ã€‘${currentCase.title || ''}`);
      lines.push(`ã€æ¿å—ã€‘${boardName}`);
      lines.push(`ã€ä½œè€…ã€‘${currentCase.author_name || ''}`);
      lines.push(`ã€å‘å¸ƒæ—¶é—´ã€‘${formatBeijingDateTime(currentCase.created_at)}ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰`);
      lines.push('');
      if(String(currentCase.summary || '').trim()){
        lines.push('ã€æ‘˜è¦ã€‘');
        lines.push(String(currentCase.summary || '').trim());
        lines.push('');
      }
      const body = String(currentCase.content || '').trim();
      if(body){
        lines.push('ã€æ­£æ–‡ã€‘');
        lines.push(body);
        lines.push('');
      }

      if(includeAttachments){
        const allAtt = [];
        for(const a of (caseAttachmentRows || [])) allAtt.push({ where:'ç—…ä¾‹', a });
        for(const [cid, arr] of (attachmentsByComment?.entries?.() || [])){
          for(const a of (arr || [])) allAtt.push({ where:`è¯„è®º#${cid}`, a });
        }
        if(allAtt.length){
          lines.push('ã€é™„ä»¶æ¸…å•ã€‘');
          for(const x of allAtt){
            const a = x.a || {};
            const nm = a.original_name || a.path || 'é™„ä»¶';
            const kind = a.kind || '';
            const url = a.public_url || '';
            lines.push(`- ${x.where}ï½œ${nm}${kind ? 'ï¼ˆ'+kind+'ï¼‰' : ''}${url ? 'ï½œ'+url : ''}`);
          }
          lines.push('');
        }
      }

      const rows = Array.isArray(commentRows) ? commentRows.filter(x=>!x?.deleted_at) : [];
      const picked = rows.slice(Math.max(0, rows.length - maxComments));
      lines.push(`ã€è®¨è®ºè¯„è®ºï¼ˆæœ€è¿‘ ${picked.length} æ¡ï¼‰ã€‘`);
      picked.forEach((c, idx)=>{
        const n = idx + 1;
        const who = c.author_name || 'Member';
        const when = c.created_at ? formatBeijingDateTime(c.created_at) + 'ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰' : '';
        const txt = String(c.body || '').trim();
        lines.push(`è¯„è®º#${n}ï½œ${who}${when ? 'ï½œ'+when : ''}`);
        lines.push(txt);

        // attachments hint for this comment (if any)
        const att = attachmentsByComment.get(String(c.id)) || [];
        if(att.length){
          lines.push(`ï¼ˆè¯¥è¯„è®ºåŒ…å«é™„ä»¶ï¼š${att.map(a=>a.original_name||a.path||'é™„ä»¶').join('ã€')}ï¼‰`);
        }
        lines.push('');
      });

      lines.push('ã€æé†’ã€‘è¯·ç¡®è®¤ä»¥ä¸Šå†…å®¹å·²å»æ ‡è¯†åŒ–ï¼ˆå§“å/ç”µè¯/ä½é™¢å·/èº«ä»½è¯ç­‰ï¼‰ã€‚å¦‚å‘ç°ç–‘ä¼¼éšç§ï¼Œè¯·å…ˆåœ¨ç½‘ç«™å†…ä¿®æ”¹åå†å¤åˆ¶ã€‚');
      return lines.join('\n');
    }

    const AI_PROMPT_VERSION = 'stage1_free_v1';

    function buildAiSummaryPrompt(){
      const prompt = [
        'ä½ æ˜¯åŒ»å­¦å­¦æœ¯è®¨è®ºæ•´ç†åŠ©æ‰‹ã€‚è¯·ä»…åŸºäºæˆ‘æä¾›çš„ç—…ä¾‹æ­£æ–‡ä¸è¯„è®ºå†…å®¹è¿›è¡Œå½’çº³æ€»ç»“ï¼Œä¸è¦ç¼–é€ æœªå‡ºç°çš„ä¿¡æ¯ã€‚',
        'ä¸è¦è¾“å‡ºä»»ä½•ä¸ªä½“åŒ–å¤„æ–¹æˆ–åŒ»ç–—å»ºè®®ï¼Œç”¨â€œè®¨è®ºä¸­æåˆ°/è§‚ç‚¹è®¤ä¸º/å¯èƒ½æ€§â€è¡¨è¿°ã€‚',
        '',
        'è¯·è¾“å‡º Markdownï¼Œä¸¥æ ¼æŒ‰ä»¥ä¸‹ç»“æ„ï¼š',
        '1) ä¸€å¥è¯æ‘˜è¦ï¼ˆâ‰¤60å­—ï¼‰',
        '2) å…³é”®ä¿¡æ¯é€Ÿè§ˆï¼ˆè¦ç‚¹åˆ—è¡¨ï¼‰',
        '3) æ—¶é—´çº¿ï¼ˆå¦‚æ–‡æœ¬é‡Œæœ‰æ—¥æœŸ/æ—¶é—´åˆ™æ•´ç†ï¼Œæ²¡æœ‰å°±è·³è¿‡ï¼‰',
        '4) è®¨è®ºç„¦ç‚¹ä¸åˆ†æ­§ï¼ˆåˆ—å‡ºä¸åŒè§‚ç‚¹åŠä¾æ®ï¼‰',
        '5) é˜¶æ®µæ€§å…±è¯†/ä¸‹ä¸€æ­¥å»ºè®®ï¼ˆä»…â€œè®¨è®ºå»ºè®®â€ï¼Œä¸å¾—ç»™ä¸ªä½“åŒ–æ²»ç–—å¤„æ–¹ï¼‰',
        '6) ä¿¡æ¯ç¼ºå£æ¸…å•ï¼ˆç¼ºå“ªäº›æ£€æŸ¥/ç—…ç†æè¿°/éšè®¿ä¿¡æ¯ï¼‰',
        '7) å¼•ç”¨æ¥æºï¼šç”¨â€œç—…ä¾‹æ­£æ–‡/è¯„è®º#ç¼–å·ï¼ˆä½œè€…ï¼Œæ—¶é—´ï¼‰â€æ ‡æ³¨',
        '',
        'é‡è¦ï¼šè¯·æé†’é¿å…ä»»ä½•å¯è¯†åˆ«ä¸ªäººä¿¡æ¯ï¼ˆå§“å/ç”µè¯/ä½é™¢å·ç­‰ï¼‰ã€‚è‹¥å‘ç°ç–‘ä¼¼ä¿¡æ¯è¯·æ ‡æ³¨â€œç–‘ä¼¼éšç§ä¿¡æ¯ï¼šxxxï¼ˆå»ºè®®åˆ é™¤ï¼‰â€ã€‚',
        '',
        '---',
        buildAiContextText({ includeAttachments: true, maxComments: 30 }),
      ].join('\n');
      return prompt;
    }

    function buildAiStructuredPrompt(){
      const prompt = [
        'ä½ æ˜¯åŒ»å­¦ç—…ä¾‹ç»“æ„åŒ–æŠ½å–åŠ©æ‰‹ã€‚è¯·ä»…æŠ½å–æˆ‘ç»™å‡ºçš„æ–‡æœ¬ä¸­æ˜ç¡®å‡ºç°çš„ä¿¡æ¯ï¼Œä¸è¦æ¨æ–­ã€ä¸è¦è¡¥å…¨ç¼ºå¤±å­—æ®µã€‚',
        'è¾“å‡ºä¸¥æ ¼ä¸º JSONï¼ˆä¸è¦å¸¦ä»»ä½•é¢å¤–è§£é‡Šæ–‡å­—ï¼‰ã€‚',
        '',
        'JSON å­—æ®µå¦‚ä¸‹ï¼ˆæ²¡æœ‰å°±ç•™ç©º/null æˆ–ä¸è¾“å‡ºè¯¥å­—æ®µï¼‰ï¼š',
        '- demographics: {sex, age}',
        '- presentation: {chief_complaint, course_summary}',
        '- key_labs: {scr, egfr, proteinuria, albumin, pla2r, complements, other}',
        '- pathology: {key_findings}',
        '- treatments: [{date_or_phase, meds, dose, response}]',
        '- followup: {outcomes}',
        '- discussion_points: [..]',
        '- open_questions: [..]',
        '- privacy_flags: [..]  ï¼ˆè‹¥æ£€æµ‹åˆ°å¯èƒ½éšç§ä¿¡æ¯ï¼Œåˆ—å‡ºå¹¶æç¤ºåˆ æ”¹ï¼‰',
        '',
        'é‡è¦ï¼šä¸å¾—è¾“å‡ºå…·ä½“å¤„æ–¹å»ºè®®ï¼›åªåšä¿¡æ¯æŠ½å–ä¸æ•´ç†ã€‚',
        '',
        '---',
        buildAiContextText({ includeAttachments: true, maxComments: 30 }),
      ].join('\n');
      return prompt;
    }

    function mountAiToolsUI(){
      if(!aiToolsBlock) return;

      if(!aiArtifactsSupported){
        aiToolsBlock.hidden = true;
        aiToolsBlock.innerHTML = '';
        return;
      }

      // Everyone who can view the case can use the copy-to-AI prompts.
      // Saving back to the site is restricted by RLS (author / doctor_verified / admin).
      const canSave = canEditAi();

      aiToolsBlock.hidden = false;
      aiToolsBlock.innerHTML = `
        <details class="note" ${isMobileViewport() ? '' : 'open'}>
          <summary style="cursor:pointer"><b>AI æ•´ç†å·¥å…·ï¼ˆå…è´¹ï¼‰</b> <span class="small muted">ï¼ˆç½‘ç«™ä¸è°ƒç”¨AIï¼›å¤åˆ¶åˆ°ä»»æ„å…è´¹AIç”Ÿæˆåç²˜è´´å›å¡«ï¼‰</span></summary>
          <div style="margin-top:10px">
            <div class="small muted" style="margin-bottom:8px">
              å»ºè®®å…ˆç¡®è®¤å·²å»æ ‡è¯†åŒ–ã€‚è‹¥æ–‡æœ¬åŒ…å«æ‰‹æœºå·/èº«ä»½è¯/ä½é™¢å·ç­‰ï¼Œè¯·å…ˆåœ¨å¸–å­ä¸­åˆ é™¤æˆ–æ‰“ç ã€‚
            </div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px">
              <button class="btn tiny" type="button" id="aiCopySummaryBtn">å¤åˆ¶AIæ€»ç»“æç¤ºè¯+å†…å®¹</button>
              <button class="btn tiny" type="button" id="aiCopyStructBtn">å¤åˆ¶ç»“æ„åŒ–æç¤ºè¯+å†…å®¹</button>
            </div>

            ${canSave ? `
              <div class="hr" style="margin:12px 0"></div>

              <label class="small muted">ç²˜è´´ AI æ€»ç»“ï¼ˆMarkdown / çº¯æ–‡æœ¬å‡å¯ï¼‰</label>
              <textarea class="input" id="aiSummaryInput" rows="10" placeholder="å°†å…è´¹AIç”Ÿæˆçš„æ€»ç»“ç²˜è´´åˆ°è¿™é‡Œâ€¦"></textarea>
              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center">
                <button class="btn primary" type="button" id="aiSaveSummaryBtn">ä¿å­˜ä¸ºè®¨è®ºæ‘˜è¦</button>
                <span class="small muted" id="aiSaveSummaryHint"></span>
              </div>

              <div class="hr" style="margin:14px 0"></div>

              <label class="small muted">ç²˜è´´ AI ç»“æ„åŒ–ç»“æœï¼ˆJSONï¼‰</label>
              <textarea class="input" id="aiStructInput" rows="10" placeholder='è¯·ç²˜è´´ JSONï¼ˆä¾‹å¦‚ï¼š{"demographics":{...}}ï¼‰'></textarea>
              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center">
                <button class="btn primary" type="button" id="aiSaveStructBtn">ä¿å­˜ç»“æ„åŒ–è¦ç‚¹</button>
                <span class="small muted" id="aiSaveStructHint"></span>
              </div>
            ` : `
              <div class="small muted" style="margin-top:10px">
                ä½ å½“å‰ä»…å¯å¤åˆ¶æç¤ºè¯ç”¨äºä¸ªäººæ•´ç†ï¼›å¦‚éœ€åœ¨ç½‘ç«™å†…ä¿å­˜æ‘˜è¦/ç»“æ„åŒ–ï¼Œè¯·è”ç³»ç®¡ç†å‘˜å¼€é€šæƒé™ï¼ˆä½œè€… / è®¤è¯åŒ»ç”Ÿ / ç®¡ç†å‘˜ï¼‰ã€‚
              </div>
            `}
          </div>
        </details>
      `;

      const copySummaryBtn = document.getElementById('aiCopySummaryBtn');
      const copyStructBtn = document.getElementById('aiCopyStructBtn');
      const summaryInput = document.getElementById('aiSummaryInput');
      const structInput = document.getElementById('aiStructInput');
      const saveSummaryBtn = document.getElementById('aiSaveSummaryBtn');
      const saveStructBtn = document.getElementById('aiSaveStructBtn');
      const summaryHint = document.getElementById('aiSaveSummaryHint');
      const structHint = document.getElementById('aiSaveStructHint');

      copySummaryBtn?.addEventListener('click', async ()=>{
        const text = buildAiSummaryPrompt();
        const flags = detectPrivacyFlags(text);
        if(flags.length){
          const ok = confirm(`æ£€æµ‹åˆ°å¯èƒ½éšç§ä¿¡æ¯ï¼š${flags.join('ã€')}\n\nå»ºè®®å…ˆåœ¨ç½‘ç«™å†…åˆ é™¤/æ‰“ç åå†å¤åˆ¶ã€‚\n\nä»è¦å¤åˆ¶å—ï¼Ÿ`);
          if(!ok) return;
        }
        const ok = await copyText(text);
        if(ok){
          toast('å·²å¤åˆ¶', 'å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚å¯ç²˜è´´åˆ°ä»»æ„å…è´¹AIç”Ÿæˆæ€»ç»“ã€‚', 'ok');
        }else{
          toast('å¤åˆ¶å¤±è´¥', 'æµè§ˆå™¨å¯èƒ½é˜»æ­¢äº†å‰ªè´´æ¿æƒé™ã€‚è¯·æ‰‹åŠ¨é€‰ä¸­å¤åˆ¶ã€‚', 'err');
        }
      });

      copyStructBtn?.addEventListener('click', async ()=>{
        const text = buildAiStructuredPrompt();
        const flags = detectPrivacyFlags(text);
        if(flags.length){
          const ok = confirm(`æ£€æµ‹åˆ°å¯èƒ½éšç§ä¿¡æ¯ï¼š${flags.join('ã€')}\n\nå»ºè®®å…ˆåœ¨ç½‘ç«™å†…åˆ é™¤/æ‰“ç åå†å¤åˆ¶ã€‚\n\nä»è¦å¤åˆ¶å—ï¼Ÿ`);
          if(!ok) return;
        }
        const ok = await copyText(text);
        if(ok){
          toast('å·²å¤åˆ¶', 'å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚å¯ç²˜è´´åˆ°ä»»æ„å…è´¹AIç”Ÿæˆç»“æ„åŒ–JSONã€‚', 'ok');
        }else{
          toast('å¤åˆ¶å¤±è´¥', 'æµè§ˆå™¨å¯èƒ½é˜»æ­¢äº†å‰ªè´´æ¿æƒé™ã€‚è¯·æ‰‹åŠ¨é€‰ä¸­å¤åˆ¶ã€‚', 'err');
        }
      });

      saveSummaryBtn?.addEventListener('click', async ()=>{
        if(!currentUser || !currentCase) return;
        const md = String(summaryInput?.value || '').trim();
        if(!md){ toast('å†…å®¹ä¸ºç©º', 'è¯·å…ˆç²˜è´´ AI æ€»ç»“å†…å®¹ã€‚', 'err'); return; }

        const flags = detectPrivacyFlags(md);
        if(flags.length){
          const ok = confirm(`æ€»ç»“å†…å®¹ä¸­æ£€æµ‹åˆ°ï¼š${flags.join('ã€')}\n\nå»ºè®®å…ˆåˆ é™¤/æ‰“ç åå†ä¿å­˜ã€‚\n\nä»è¦ä¿å­˜å—ï¼Ÿ`);
          if(!ok) return;
        }

        saveSummaryBtn.disabled = true;
        if(summaryHint) summaryHint.textContent = 'ä¿å­˜ä¸­â€¦';
        try{
          aiSourceHashNow = computeAiSourceHash();
          const creatorName = currentProfile?.full_name || currentUser.email || 'Member';
          const row = {
            case_id: Number(currentCase.id),
            kind: 'summary_md',
            content_md: md,
            content_json: null,
            source_hash: aiSourceHashNow,
            prompt_version: AI_PROMPT_VERSION,
            model: 'manual_free_ai',
            created_by: currentUser.id,
            creator_name: creatorName,
          };

          // Prefer upsert by unique key (case_id, kind)
          const res = await supabase
            .from('case_ai_artifacts')
            .upsert(row, { onConflict: 'case_id,kind' });
          if(res?.error) throw res.error;

          toast('å·²ä¿å­˜', 'è®¨è®ºæ‘˜è¦å·²æ›´æ–°ã€‚', 'ok');
          await loadAiArtifacts();
          renderAiSummary();
        }catch(e){
          const msg = String(e?.message || e || '');
          if(/case_ai_artifacts/i.test(msg) && /(does not exist|relation|schema cache|could not find|not find)/i.test(msg)){
            toast('AIæ‘˜è¦æœªåˆå§‹åŒ–', 'è¯·åœ¨ Supabase SQL Editor è¿è¡Œ MIGRATION_20260118_CASE_AI_ARTIFACTS.sqlï¼Œç„¶å Settings â†’ API ç‚¹å‡» â€œReload schemaâ€ã€‚', 'err');
          }else{
            toast('ä¿å­˜å¤±è´¥', msg, 'err');
          }
        }finally{
          saveSummaryBtn.disabled = false;
          if(summaryHint) summaryHint.textContent = '';
        }
      });

      saveStructBtn?.addEventListener('click', async ()=>{
        if(!currentUser || !currentCase) return;
        const raw = String(structInput?.value || '').trim();
        if(!raw){ toast('å†…å®¹ä¸ºç©º', 'è¯·å…ˆç²˜è´´ AI è¾“å‡ºçš„ JSONã€‚', 'err'); return; }
        let obj = null;
        try{ obj = JSON.parse(raw); }catch(_e){
          toast('JSON æ ¼å¼é”™è¯¯', 'è¯·ç¡®ä¿ç²˜è´´çš„æ˜¯ä¸¥æ ¼ JSONï¼ˆä¸å¸¦å¤šä½™è§£é‡Šæ–‡å­—ï¼‰ã€‚', 'err');
          return;
        }

        saveStructBtn.disabled = true;
        if(structHint) structHint.textContent = 'ä¿å­˜ä¸­â€¦';
        try{
          aiSourceHashNow = computeAiSourceHash();
          const creatorName = currentProfile?.full_name || currentUser.email || 'Member';
          const row = {
            case_id: Number(currentCase.id),
            kind: 'structured_json',
            content_md: null,
            content_json: obj,
            source_hash: aiSourceHashNow,
            prompt_version: AI_PROMPT_VERSION,
            model: 'manual_free_ai',
            created_by: currentUser.id,
            creator_name: creatorName,
          };
          const res = await supabase
            .from('case_ai_artifacts')
            .upsert(row, { onConflict: 'case_id,kind' });
          if(res?.error) throw res.error;
          toast('å·²ä¿å­˜', 'ç»“æ„åŒ–è¦ç‚¹å·²æ›´æ–°ã€‚', 'ok');
          await loadAiArtifacts();
          renderAiStructured();
        }catch(e){
          const msg = String(e?.message || e || '');
          if(/case_ai_artifacts/i.test(msg) && /(does not exist|relation|schema cache|could not find|not find)/i.test(msg)){
            toast('AIç»“æ„åŒ–æœªåˆå§‹åŒ–', 'è¯·åœ¨ Supabase SQL Editor è¿è¡Œ MIGRATION_20260118_CASE_AI_ARTIFACTS.sqlï¼Œç„¶å Settings â†’ API ç‚¹å‡» â€œReload schemaâ€ã€‚', 'err');
          }else{
            toast('ä¿å­˜å¤±è´¥', msg, 'err');
          }
        }finally{
          saveStructBtn.disabled = false;
          if(structHint) structHint.textContent = '';
        }
      });
    }

    async function loadAiArtifacts(){
      if(!currentCase) return;
      aiArtifactsSupported = true;
      try{
        const { data, error } = await supabase
          .from('case_ai_artifacts')
          .select('id, case_id, kind, content_md, content_json, source_hash, created_by, creator_name, created_at, updated_at')
          .eq('case_id', Number(currentCase.id));
        if(error) throw error;

        const rows = Array.isArray(data) ? data : [];
        aiSummaryRow = rows.find(r => String(r.kind) === 'summary_md') || null;
        aiStructuredRow = rows.find(r => String(r.kind) === 'structured_json') || null;
      }catch(e){
        // Table not initialized: hide silently (but keep clear errors on save)
        aiArtifactsSupported = false;
        aiSummaryRow = null;
        aiStructuredRow = null;
      }
    }

    // ------------------------------
    // UI: Attachments picker bindings
    // ------------------------------
    renderAttachDraft();
    if(attachClearBtn) attachClearBtn.disabled = true;

    attachPickBtn?.addEventListener('click', ()=>{
      attachInput?.click();
    });
    attachClearBtn?.addEventListener('click', ()=>{
      clearAttachDraft();
    });
    attachInput?.addEventListener('change', (e)=>{
      addAttachFiles(e.target.files);
    });
    attachPreview?.addEventListener('click', (e)=>{
      const btn = e.target?.closest?.('[data-attach-remove]');
      if(!btn) return;
      const id = String(btn.getAttribute('data-attach-remove') || '');
      if(!id) return;
      attachPicks = attachPicks.filter(x => x.id !== id);
      renderAttachDraft();
    });

    // Drag & drop / paste attachments directly into the composer
    (function bindComposerPasteAndDrop(){
      if(!commentDropEl) return;
      const targets = [commentDropEl, attachPreview, form].filter(Boolean);
      const setHover = (on) => {
        try{ (commentHoverEl || commentDropEl).classList.toggle('drop-hover', !!on); }catch(_e){}
      };

      targets.forEach(t=>{
        t.addEventListener('dragover', (e)=>{
          const types = Array.from(e.dataTransfer?.types || []);
          if(types.includes('Files')){
            e.preventDefault();
            setHover(true);
          }
        });
        t.addEventListener('dragleave', ()=> setHover(false));
        t.addEventListener('drop', (e)=>{
          const files = e.dataTransfer?.files;
          if(files && files.length){
            e.preventDefault();
            setHover(false);
            addAttachFiles(files);
            toast('å·²æ·»åŠ é™„ä»¶', `å·²æ·»åŠ  ${files.length} ä¸ªæ–‡ä»¶`, 'ok');
          }
        });
      });

      commentDropEl.addEventListener('paste', (e)=>{
        const dt = e.clipboardData;
        if(!dt) return;
        const files = [];
        for(const item of Array.from(dt.items || [])){
          if(item.kind === 'file'){
            const f = item.getAsFile();
            if(f) files.push(f);
          }
        }
        if(!files.length) return;
        const hasText = Boolean(dt.getData('text/plain'));
        if(!hasText) e.preventDefault();
        addAttachFiles(files);
        toast('å·²æ·»åŠ é™„ä»¶', 'å·²ä»å‰ªè´´æ¿æ·»åŠ ', 'ok');
      });
    })();

    // ------------------------------
    // UI: Thread modal
    // ------------------------------
    function closeCommentModal(){
      openCommentId = null;
      if(modalEl) modalEl.hidden = true;
      if(modalBody) modalBody.innerHTML = '';
      if(modalAttaches) modalAttaches.innerHTML = '';
      if(modalLikeBtn){
        modalLikeBtn.dataset.commentId = '';
        modalLikeBtn.dataset.liked = '0';
        modalLikeBtn.dataset.count = '0';
        modalLikeBtn.classList.remove('primary');
        modalLikeBtn.textContent = 'ğŸ‘ ç‚¹èµ Â· 0';
      }
    }

    function openCommentModal(commentId){
      const id = Number(commentId);
      const c = commentRows.find(r => Number(r.id) === id);
      if(!c) return;
      openCommentId = id;
      const when = c.created_at ? formatBeijingDateTime(c.created_at) : '';

      if(modalAuthor) modalAuthor.textContent = c.author_name || 'Member';
      if(modalWhen) modalWhen.textContent = when;
      if(modalBody){
        const bHtml = String(c.body_html || '').trim();
        modalBody.innerHTML = bHtml
          ? renderSafeHtml(bHtml, { mode:'comment', linkify:true, mentionify:true })
          : renderRichText(String(c.body || ''));
      }

      // Like status in modal
      if(modalLikeBtn){
        if(!commentLikeSupported){
          modalLikeBtn.hidden = true;
        }else{
          modalLikeBtn.hidden = false;
          const cnt = Number(c.like_count || 0);
          const isLiked = likedCommentIds && typeof likedCommentIds.has === 'function' ? likedCommentIds.has(String(c.id)) : false;
          modalLikeBtn.dataset.commentId = String(c.id);
          modalLikeBtn.dataset.liked = isLiked ? '1' : '0';
          modalLikeBtn.dataset.count = String(cnt);
          modalLikeBtn.classList.toggle('primary', isLiked);
          modalLikeBtn.textContent = (isLiked ? 'ğŸ’™ å·²èµ' : 'ğŸ‘ ç‚¹èµ') + ' Â· ' + cnt;
        }
      }

      const attaches = attachmentsByComment.get(String(id)) || [];
      if(modalAttaches){
        modalAttaches.innerHTML = attaches.length ? (`<div class="small muted" style="margin-bottom:8px">é™„ä»¶</div>` + renderAttachmentsBlock(attaches)) : '';
      }

      const uid = currentUser?.id || '';
      const canDel = Boolean(
        uid
        && (
          isAdminUi
          || isModeratorUser
          || isBoardModeratorUser
          || (currentCase && String(currentCase.author_id) === String(uid))
          || String(uid) === String(c.author_id)
        )
      );
      if(modalDeleteBtn){
        modalDeleteBtn.hidden = !canDel;
      }
      if(modalEl) modalEl.hidden = false;
    }

    modalCloseBtn?.addEventListener('click', closeCommentModal);
    modalEl?.addEventListener('click', (e)=>{
      if(e.target === modalEl) closeCommentModal();
    });
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && modalEl && !modalEl.hidden) closeCommentModal();
    });

    // Delegation for comment list (like / reply / delete)
    listEl?.addEventListener('click', async (e)=>{
      const lk = e.target?.closest?.('[data-like-comment]');
      if(lk){
        e.preventDefault();
        e.stopPropagation();
        const id = Number(lk.getAttribute('data-like-comment') || 0);
        if(!id) return;
        await toggleCaseCommentLike(id);
        return;
      }

      const rep = e.target?.closest?.('[data-reply-comment]');
      if(rep){
        e.preventDefault();
        e.stopPropagation();
        const id = Number(rep.getAttribute('data-reply-comment') || 0);
        if(!id) return;
        replyToComment(id);
        return;
      }

      const del = e.target?.closest?.('[data-del-comment]');
      if(del){
        e.preventDefault();
        e.stopPropagation();
        const id = Number(del.getAttribute('data-del-comment') || 0);
        if(!id) return;
        if(!confirm('ç¡®å®šåˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) return;
        try{
          await deleteCommentSafe(id);
          toast('å·²åˆ é™¤', 'è¯„è®ºå·²åˆ é™¤ã€‚', 'ok');
          closeCommentModal();
          await loadComments();
        }catch(err){
          toast('åˆ é™¤å¤±è´¥', _humanizeRlsError(err), 'err');
        }
        return;
      }
    });

    // Modal delete button
    modalLikeBtn?.addEventListener('click', async ()=>{
      if(!commentLikeSupported) return;
      const id = Number(modalLikeBtn.dataset.commentId || openCommentId || 0);
      if(!id) return;
      await toggleCaseCommentLike(id);
    });

    // Modal delete button
    modalDeleteBtn?.addEventListener('click', async ()=>{
      if(!openCommentId) return;
      if(!confirm('ç¡®å®šåˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) return;
      try{
        await deleteCommentSafe(openCommentId);
        toast('å·²åˆ é™¤', 'è¯„è®ºå·²åˆ é™¤ã€‚', 'ok');
        closeCommentModal();
        await loadComments();
      }catch(err){
        toast('åˆ é™¤å¤±è´¥', _humanizeRlsError(err), 'err');
      }
    });

    // ------------------------------
    // Delete helpers (RPC preferred, fallback to soft-delete update)
    // ------------------------------
    function _isMissingRpc(err, fnName){
      const msg = String((err && (err.message || err.error_description)) ? (err.message || err.error_description) : (err || ''));
      return msg.includes('PGRST202') || msg.includes('Could not find the function') || (msg.includes('function') && msg.includes(fnName));
    }

    function _humanizeRlsError(err){
      const msg = String((err && (err.message || err.error_description)) ? (err.message || err.error_description) : (err || ''));
      if(/row-level security|rls|permission denied|403/i.test(msg)){
        return msg + '\n\næç¤ºï¼šè¿™é€šå¸¸æ˜¯ Supabase çš„ RLS æƒé™/ç­–ç•¥æœªé…ç½®å¥½å¯¼è‡´ã€‚è¯·åœ¨ Supabase â†’ SQL Editor é‡æ–°è¿è¡Œæœ€æ–°ç‰ˆ SUPABASE_SETUP.sqlï¼Œç„¶ååˆ° Settings â†’ API æ‰§è¡Œ Reload schema å†é‡è¯•ã€‚';
      }
      return msg;
    }

    async function deleteCaseSafe(caseId){
      const nowIso = new Date().toISOString();

      // 1) Prefer RPC (bypasses tricky RLS edge cases)
      try{
        const { error } = await supabase.rpc('delete_case', { _case_id: caseId });
        if(!error) return;
        if(!_isMissingRpc(error, 'delete_case')) throw error;
      }catch(e){
        if(!_isMissingRpc(e, 'delete_case')) throw e;
      }

      // 2) Fallback: soft delete via update (requires correct RLS)
      const { error: uerr } = await supabase
        .from('cases')
        .update({ deleted_at: nowIso })
        .eq('id', caseId);

      if(uerr) throw uerr;
    }

    async function deleteCommentSafe(commentId){
      const nowIso = new Date().toISOString();

      // 1) Prefer RPC
      try{
        const { error } = await supabase.rpc('delete_case_comment', { _comment_id: commentId });
        if(!error) return;
        if(!_isMissingRpc(error, 'delete_case_comment')) throw error;
      }catch(e){
        if(!_isMissingRpc(e, 'delete_case_comment')) throw e;
      }

      // 2) Fallback: soft delete via update
      const { error: uerr } = await supabase
        .from('case_comments')
        .update({ deleted_at: nowIso })
        .eq('id', commentId);

      if(uerr) throw uerr;
    }

    function updateCaseCommentLikeUI(commentId){
      const id = String(commentId);
      const row = commentRows.find(r => String(r.id) === id);
      const cnt = Number(row?.like_count || 0);
      const isLiked = likedCommentIds && typeof likedCommentIds.has === 'function' ? likedCommentIds.has(id) : false;

      // Update list buttons
      document.querySelectorAll(`[data-like-comment="${id}"]`).forEach(btn=>{
        btn.dataset.liked = isLiked ? '1' : '0';
        btn.dataset.count = String(cnt);
        btn.classList.toggle('primary', isLiked);
        btn.textContent = (isLiked ? 'ğŸ’™ å·²èµ' : 'ğŸ‘ ç‚¹èµ') + ' Â· ' + cnt;
      });

      // Update mobile collapsed hint (summary)
      document.querySelectorAll(`[data-like-hint="${id}"]`).forEach(el=>{
        const attaches = attachmentsByComment.get(id) || [];
        el.textContent = `ğŸ‘ ${cnt}${attaches.length ? ` Â· ğŸ“ ${attaches.length}` : ''}`;
      });

      // Update modal button
      if(modalLikeBtn && String(modalLikeBtn.dataset.commentId || '') === id){
        modalLikeBtn.dataset.liked = isLiked ? '1' : '0';
        modalLikeBtn.dataset.count = String(cnt);
        modalLikeBtn.classList.toggle('primary', isLiked);
        modalLikeBtn.textContent = (isLiked ? 'ğŸ’™ å·²èµ' : 'ğŸ‘ ç‚¹èµ') + ' Â· ' + cnt;
      }
    }

    async function toggleCaseCommentLike(commentId){
      if(!commentLikeSupported){
        toast('æš‚æœªå¼€å¯', 'è¯¥ç¯å¢ƒæœªå¼€å¯è¯„è®ºç‚¹èµåŠŸèƒ½ï¼ˆè¯·è¿è¡Œæœ€æ–°è¿ç§» SQLï¼‰ã€‚', 'err');
        return;
      }
      if(!isConfigured() || !supabase){
        toast('æœªé…ç½®', 'Supabase æœªé…ç½®ã€‚', 'err');
        return;
      }
      if(!currentUser){
        toast('è¯·å…ˆç™»å½•', 'ç™»å½•åæ‰èƒ½ç‚¹èµã€‚', 'err');
        return;
      }

      const id = String(commentId);
      const row = commentRows.find(r => String(r.id) === id);
      const curCount = Number(row?.like_count || 0);
      const isLiked = likedCommentIds && typeof likedCommentIds.has === 'function' ? likedCommentIds.has(id) : false;

      try{
        if(!isLiked){
          const { error } = await supabase
            .from('case_comment_likes')
            .insert({ comment_id: Number(commentId), user_id: currentUser.id });
          if(error) throw error;
          likedCommentIds.add(id);
          if(row) row.like_count = curCount + 1;
        }else{
          const { error } = await supabase
            .from('case_comment_likes')
            .delete()
            .eq('comment_id', Number(commentId))
            .eq('user_id', currentUser.id);
          if(error) throw error;
          likedCommentIds.delete(id);
          if(row) row.like_count = Math.max(0, curCount - 1);
        }

        updateCaseCommentLikeUI(commentId);
      }catch(e){
        const msg = String(e?.message || e || '');
        if(/relation .*case_comment_likes.* does not exist/i.test(msg)){
          commentLikeSupported = false;
          toast('æœªå¼€å¯ç‚¹èµè¡¨', 'è¯·å…ˆåœ¨ Supabase SQL Editor æ‰§è¡Œæœ€æ–°ç‰ˆè¿ç§»ï¼ˆåˆ›å»º case_comment_likesï¼‰ã€‚', 'err');
          await loadComments();
          return;
        }
        toast('æ“ä½œå¤±è´¥', _humanizeRlsError(e), 'err');
      }
    }


    async function loadCase(){
      if(!caseId || Number.isNaN(caseId)){
        setError('ç¼ºå°‘ç—…ä¾‹ idã€‚è¯·ä»ç¤¾åŒºæ¿å—åˆ—è¡¨è¿›å…¥ã€‚');
        return;
      }

      if(isConfigured()){
        const ok = await ensureAuthed('login.html');
        if(!ok) return;
      }

      setLoading();

      try{
        if(!isConfigured() || !supabase){
          setError('Supabase æœªé…ç½®ã€‚è¯·å…ˆåœ¨ assets/config.js å¡«å†™é…ç½®ã€‚');
          return;
        }

        currentUser = await getCurrentUser();
        currentProfile = currentUser ? await getUserProfile(currentUser) : null;
        const role = normalizeRole(currentProfile?.role || currentUser?.user_metadata?.role || 'member');
        isAdminUser = isAdminRole(role);
        isModeratorUser = (String(role || '').toLowerCase() === 'moderator');
        // Admin users can optionally browse in "member view" (hide admin UI)
        const viewMode = (localStorage.getItem('ks_view_mode') || 'member');
        isAdminUi = Boolean(isAdminUser && viewMode === 'admin');

        // Doctor verification gate (Channel A: invite code)
        // - Applies to: replying in case discussion + uploading attachments
        // - Backend RLS is the final enforcement
        // NOTE: board moderators should also be allowed; we finalize this after
        // we load board_moderators for the current case board.
        const baseCanPost = Boolean(
          isAdminRole(role)
          || String(role || '').toLowerCase() === 'owner'
          || String(role || '').toLowerCase() === 'moderator'
          || String(role || '').toLowerCase() === 'doctor_verified'
          || String(role || '').toLowerCase() === 'doctor'
        );
        canPostCaseComments = baseCanPost;

        const { data: c, error } = await supabase
          .from('cases')
          .select('*')
          .eq('id', caseId)
          .maybeSingle();

        if(error) throw error;
        if(!c) { setError('æœªæ‰¾åˆ°è¯¥ç—…ä¾‹ï¼Œæˆ–ä½ æ²¡æœ‰æƒé™æŸ¥çœ‹ã€‚'); return; }
        if(c.deleted_at){ setError('è¯¥ç—…ä¾‹å·²è¢«ä½œè€…åˆ é™¤ã€‚'); return; }

        currentCase = c;

        // Load moderators for this board (for "ç‰ˆä¸»" badges)
        await loadBoardModerators(c.board);

        // Board moderator permissions (post/reply/delete)
        isBoardModeratorUser = Boolean(
          currentUser && moderatorIds && typeof moderatorIds.has === 'function' && moderatorIds.has(String(currentUser.id))
        );
        canPostCaseComments = Boolean(baseCanPost || isBoardModeratorUser);
        applyDoctorGateUI();

        // Badge label depends on board type (ç—…ä¾‹ / æ–‡çŒ® / ç§‘ç ”)
        const badgeEl = document.getElementById('caseBadge');
        if(badgeEl){
          const b = String(c.board || '').toLowerCase();
          if(b === 'research') badgeEl.textContent = 'Research Â· ç§‘ç ”è®¨è®º';
          else if(b === 'literature') badgeEl.textContent = 'Journal Club Â· æ–‡çŒ®å­¦ä¹ ';
          else badgeEl.textContent = 'Case Â· ç—…ä¾‹';
        }

        titleEl.textContent = c.title || 'ï¼ˆæ— æ ‡é¢˜ï¼‰';
        const __authorName = esc(c.author_name || 'Member');
        const __modBadge = (moderatorIds && moderatorIds.has(c.author_id)) ? ' <span class="badge mod mini">ç‰ˆä¸»</span>' : '';
        metaEl.innerHTML = `ä½œè€…ï¼š<b>${__authorName}</b>${__modBadge} Â· ${formatBeijingDateTime(c.created_at)}`;

        // Like count (quality signal)
        if(likeCountEl){
          const lc = Number(c.like_count || 0);
          likeCountEl.textContent = String(Number.isFinite(lc) ? lc : 0);
        }

        tagsEl.innerHTML = (c.tags || []).map(tagChip).join(' ');

        const content = (c.content || '').trim();
        if(content){
          bodyEl.innerHTML = `<div style="white-space:pre-wrap;line-height:1.75">${esc(content)}</div>`;
        }else{
          const sumHtml = String(c.summary_html || '').trim();
          const sumRendered = sumHtml ? renderSafeHtml(sumHtml, { mode:'comment', linkify:true, mentionify:true }) : '';
          bodyEl.innerHTML = `
            <div class="note">
              <b>æ‘˜è¦ï¼š</b>
              <div class="ks-prose" style="margin-top:8px">
                ${sumRendered || `<div style="white-space:pre-wrap;line-height:1.75">${esc(c.summary || '') || 'ï¼ˆæ— æ‘˜è¦ï¼‰'}</div>`}
              </div>
              <div class="small muted" style="margin-top:8px">
                ç›®å‰æ­£æ–‡ç»“æ„è¿˜åœ¨è¿­ä»£ä¸­ã€‚å·²æ”¯æŒé™„ä»¶ä¸Šä¼ ï¼›åç»­å°†è¡¥å……ç»“æ„åŒ–æ¨¡æ¿ã€‚
              </div>
            </div>
          `;
        }

        await loadCaseAttachments();

        const canDelete = Boolean(
          (currentUser && (String(currentUser.id) === String(c.author_id)))
          || isAdminUi
          || isModeratorUser
          || isBoardModeratorUser
        );
        delBtn.hidden = !canDelete;
        if (canDelete) {
  // ç”¨ onclick è¦†ç›–ï¼Œé¿å…é‡å¤ç»‘å®š
  delBtn.onclick = async () => {
    if (!confirm('ç¡®å®šåˆ é™¤è¯¥ç—…ä¾‹å—ï¼Ÿåˆ é™¤åæ™®é€šç”¨æˆ·ä¸å¯è§ã€‚')) return;

    // â˜… åˆ é™¤å‰å†æ¬¡ç¡®ä¿æ˜¯ authenticatedï¼ˆç¨³ï¼‰
    if (isConfigured()) {
      const ok = await ensureAuthed('login.html');
      if (!ok) return;
    }

    // é˜²æ­¢è¿ç‚¹
    delBtn.disabled = true;

    try {
      // ä¼˜å…ˆä½¿ç”¨ RPCï¼ˆæ›´ç¨³ï¼Œé¿å… RLS è¾¹ç•Œé—®é¢˜ï¼‰ï¼›è‹¥æœªéƒ¨ç½² RPCï¼Œåˆ™å›é€€åˆ°è½¯åˆ é™¤ update
      await deleteCaseSafe(currentCase.id);

      toast('å·²åˆ é™¤', 'ç—…ä¾‹å·²åˆ é™¤ã€‚', 'ok');
      setTimeout(() => location.href = 'community.html', 600);
    } catch (e) {
      toast('åˆ é™¤å¤±è´¥', _humanizeRlsError(e), 'err');
      delBtn.disabled = false;
    }
  };
}


        await loadComments();

        // AI (æš‚åœ)ï¼šå½“å‰ç‰ˆæœ¬ä¸åœ¨ç«™å†…å±•ç¤º AI æ‘˜è¦/ç»“æ„åŒ–å·¥å…·
        if(ENABLE_AI_FEATURES){
          aiSourceHashNow = computeAiSourceHash();
          await loadAiArtifacts();
          renderAiSummary();
          renderAiStructured();
          mountAiToolsUI();
        }else{
          if(aiSummaryBlock){ aiSummaryBlock.innerHTML = ''; aiSummaryBlock.hidden = true; }
          if(aiStructuredBlock){ aiStructuredBlock.innerHTML = ''; aiStructuredBlock.hidden = true; }
          if(aiToolsBlock){ aiToolsBlock.innerHTML = ''; aiToolsBlock.hidden = true; }
        }

        await loadLikeState();
      await loadFavState();
      }catch(e){
        setError(e.message || String(e));
      }
    }

    function updateLikeBtn(){
      if(!likeBtn || !likeCountEl) return;
      const prefix = liked ? 'ğŸ’™ å·²èµ ' : 'ğŸ‘ èµ ';
      if(likeBtn.firstChild && likeBtn.firstChild.nodeType === Node.TEXT_NODE){
        likeBtn.firstChild.textContent = prefix;
      }else{
        // fallback
        likeBtn.insertBefore(document.createTextNode(prefix), likeBtn.firstChild);
      }
      likeBtn.classList.toggle('primary', liked);
    }

    

      function updateFavBtn(){
        if(!favBtn) return;
        const label = faved ? 'â­ å·²æ”¶è—' : 'â­ æ”¶è—';
        favBtn.textContent = label;
        favBtn.classList.toggle('primary', faved);
      }

      async function loadFavState(){
        if(!favBtn) return;
        updateFavBtn();
        if(!currentUser || !currentCase) return;
        try{
          const { data, error } = await supabase
            .from('case_favorites')
            .select('case_id')
            .eq('case_id', currentCase.id)
            .eq('user_id', currentUser.id)
            .maybeSingle();
          if(error){
            favSupported = false;
            return;
          }
          faved = !!data;
          updateFavBtn();
        }catch(_e){
          favSupported = false;
        }
      }


      async function loadLikeState(){
      if(!likeBtn || !likeCountEl) return;
      if(!isConfigured() || !supabase) return;
      if(!currentUser || !currentCase) return;

      try{
        const { data, error } = await supabase
          .from('case_likes')
          .select('case_id')
          .eq('case_id', currentCase.id)
          .eq('user_id', currentUser.id)
          .maybeSingle();

        if(error){
          // Table may not exist yet; gracefully hide the feature.
          likeSupported = false;
          likeBtn.hidden = true;
          return;
        }
        liked = !!data;
        updateLikeBtn();
      }catch(_e){
        likeSupported = false;
        likeBtn.hidden = true;
      }
    }

    async function loadComments(){
      if(!currentCase) return;
      try{
        const isMissingColumn = (err, col)=>{
          const msg = String(err?.message || err || '').toLowerCase();
          const c = String(col || '').toLowerCase();
          return msg.includes(c) && (msg.includes('does not exist') || msg.includes('column') || msg.includes('schema cache'));
        };

        const selWithHtml = 'id, created_at, case_id, author_id, author_name, body, body_html, like_count, deleted_at';
        const selLegacy = 'id, created_at, case_id, author_id, author_name, body, like_count, deleted_at';

        let data = null;
        let error = null;
        {
          const res = await supabase
            .from('case_comments')
            .select(selWithHtml)
            .eq('case_id', currentCase.id)
            .order('created_at', { ascending: true });
          data = res.data;
          error = res.error;
          if(error && isMissingColumn(error, 'body_html')){
            const res2 = await supabase
              .from('case_comments')
              .select(selLegacy)
              .eq('case_id', currentCase.id)
              .order('created_at', { ascending: true });
            data = res2.data;
            error = res2.error;
          }
        }

        if(error) throw error;

        const rows = (data || []).filter(x => !x.deleted_at);
        commentRows = rows;

        // Load attachments (optional: table may not exist yet)
        attachmentsByComment = new Map();
        const ids = rows.map(r => Number(r.id)).filter(Boolean);
        if(ids.length){
          try{
            const { data: at, error: atErr } = await supabase
              .from('attachments')
              .select('id, created_at, target_id, author_id, author_name, bucket, path, public_url, mime_type, original_name, size_bytes, kind, deleted_at')
              .eq('target_type', 'case_comment')
              .in('target_id', ids)
              .is('deleted_at', null)
              .order('created_at', { ascending: true });
            if(!atErr && Array.isArray(at)){
              await hydrateSignedUrlsForAttachments(at);
              at.forEach(a=>{
                const k = String(a.target_id);
                if(!attachmentsByComment.has(k)) attachmentsByComment.set(k, []);
                attachmentsByComment.get(k).push(a);
              });
            }
          }catch(_e){
            // ignore
          }
        }

        // Load which comments the current user has liked (optional)
        likedCommentIds = new Set();
        commentLikeSupported = true;
        if(currentUser && ids.length){
          try{
            const { data: likes, error: lErr } = await supabase
              .from('case_comment_likes')
              .select('comment_id')
              .eq('user_id', currentUser.id)
              .in('comment_id', ids);
            if(lErr) throw lErr;
            if(Array.isArray(likes)){
              likedCommentIds = new Set(likes.map(x => String(x.comment_id)));
            }
          }catch(_e){
            // Table may not exist yet; gracefully hide the feature.
            commentLikeSupported = false;
          }
        }

        _lastMobile = isMobileViewport();
        renderCommentList();

        // Refresh AI artifacts staleness after comments/attachments changed
        try{
          aiSourceHashNow = computeAiSourceHash();
          if(aiSummaryRow) renderAiSummary();
          if(aiStructuredRow) renderAiStructured();
        }catch(_e){}

      }catch(e){
        listEl.innerHTML = `<div class="muted small">è¯»å–è¯„è®ºå¤±è´¥ï¼š${esc(e.message || String(e))}</div>`;
      }
    }

    form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      if(isConfigured()){
        const ok = await ensureAuthed('login.html');
        if(!ok) return;
      }
      if(!currentUser){ toast('è¯·å…ˆç™»å½•', 'ç™»å½•åå¯å›å¤ã€‚', 'err'); return; }
      if(!canPostCaseComments){ toast('éœ€è¦åŒ»ç”Ÿè®¤è¯', 'å›å¤ç—…ä¾‹è®¨è®ºä¸ä¸Šä¼ é™„ä»¶éœ€è¦å…ˆå®ŒæˆåŒ»ç”Ÿè®¤è¯ï¼ˆé‚€è¯·ç å¿«é€Ÿè®¤è¯æˆ–äººå·¥å®¡æ ¸ï¼‰ã€‚', 'err'); return; }
      const body = (bodyInput.value || '').trim();
      if(!body){ toast('è¯·è¾“å…¥å†…å®¹', 'è¯„è®ºä¸èƒ½ä¸ºç©ºã€‚', 'err'); return; }

      const body_html = (commentEditor && body) ? String(commentEditor.getHtml() || '').trim() : '';

      submitBtn.disabled = true;
      hintEl.textContent = 'æäº¤ä¸­â€¦';

      try{
        const name = currentProfile?.full_name || currentUser.email || 'Member';

        // 1) Insert comment first (get id)

        const isMissingColumn = (err, col)=>{
          const msg = String(err?.message || err || '').toLowerCase();
          const c = String(col || '').toLowerCase();
          return msg.includes(c) && (msg.includes('does not exist') || msg.includes('column') || msg.includes('schema cache'));
        };

        const insertPayload = {
          case_id: currentCase.id,
          author_id: currentUser.id,
          author_name: name,
          body,
          body_html: body_html || null,
          deleted_at: null,
        };

        let ins = await supabase
          .from('case_comments')
          .insert(insertPayload)
          .select('id');

        if(ins?.error && isMissingColumn(ins.error, 'body_html')){
          const retry = { ...insertPayload };
          delete retry.body_html;
          ins = await supabase.from('case_comments').insert(retry).select('id');
        }

        if(ins?.error) throw ins.error;
        const commentId = Array.isArray(ins?.data) ? ins.data?.[0]?.id : ins?.data?.id;

        // 2) Upload attachments (optional)
        if(commentId && attachPicks.length){
          try{
            const total = attachPicks.length;
            for(let i=0;i<total;i++){
              const f = attachPicks[i]?.file;
              if(!f) continue;
              hintEl.textContent = `ä¸Šä¼ é™„ä»¶ ${i+1}/${total}â€¦`;

              const kind = guessKindFromMime(f.type, f.name);
              const rid = (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(16).slice(2)}`;
              const key = `${currentUser.id}/case_comment/${commentId}/${rid}_${safeFilename(f.name)}`;

              const up = await supabase
                .storage
                .from('attachments')
                .upload(key, f, { upsert:false, contentType: f.type || undefined, cacheControl: '3600' });
              if(up?.error) throw up.error;

              const url = null; // attachments bucket is private; resolve via signed URLs when rendering

              const ares = await supabase
                .from('attachments')
                .insert({
                  target_type: 'case_comment',
                  target_id: Number(commentId),
                  author_id: currentUser.id,
                  author_name: name,
                  bucket: 'attachments',
                  path: key,
                  public_url: url,
                  mime_type: f.type || null,
                  original_name: f.name || null,
                  size_bytes: f.size || null,
                  kind,
                  deleted_at: null,
                });
              if(ares?.error){
                // If attachments table is not deployed, show a clear hint
                const msg = String(ares.error.message || ares.error);
                if(/relation .*attachments.* does not exist|does not exist|PGRST/i.test(msg)){
                  throw new Error('é™„ä»¶åŠŸèƒ½æœªåˆå§‹åŒ–ï¼šè¯·åœ¨ Supabase SQL Editor è¿è¡Œæœ€æ–°ç‰ˆ SUPABASE_SETUP.sqlï¼ˆåŒ…å« attachments è¡¨ä¸ Storage bucketï¼‰ï¼Œç„¶ååˆ° Settings â†’ API ç‚¹å‡» Reload schemaã€‚');
                }
                throw ares.error;
              }
            }
          }catch(attErr){
            toast('é™„ä»¶ä¸Šä¼ å¤±è´¥', attErr.message || String(attErr), 'err');
          }
        }

        if(commentEditor) commentEditor.setHtml('');
        bodyInput.value = '';
        clearAttachDraft();
        toast('å‘å¸ƒæˆåŠŸ', 'å›å¤å·²å‘å¸ƒã€‚', 'ok');
        await loadComments();
      }catch(err){
        toast('å‘å¸ƒå¤±è´¥', err.message || String(err), 'err');
      }finally{
        submitBtn.disabled = false;
        hintEl.textContent = '';
      }
    });

    // Mentions in case comment composer
    mentionAuthorBtn?.addEventListener('click', ()=>{
      if(!currentCase){
        toast('å°šæœªåŠ è½½å®Œæˆ', 'ç—…ä¾‹è¿˜åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨åå†è¯•ã€‚', 'err');
        return;
      }
      const name = currentCase.author_name || 'ä½œè€…';
      const id = currentCase.author_id || '';
      const mention = formatMention({ id, full_name: name }) + ' ';
      if(commentEditor) commentEditor.insertText(mention);
      else insertAtCursor(bodyInput, mention);
      commentEditor ? commentEditor.focus() : bodyInput?.focus?.();
    });

    mentionDoctorBtn?.addEventListener('click', async ()=>{
      if(isConfigured()){
        const ok = await ensureAuthed('login.html');
        if(!ok) return;
      }
      if(!currentUser){
        toast('è¯·å…ˆç™»å½•', 'ç™»å½•åæ‰èƒ½ @åŒ»ç”Ÿã€‚', 'err');
        return;
      }
      const p = await pickDoctor({ title: '@åŒ»ç”Ÿ', placeholder: 'æœç´¢åŒ»ç”Ÿå§“åâ€¦' });
      if(!p) return;
      const mention = formatMention(p) + ' ';
      if(commentEditor) commentEditor.insertText(mention);
      else insertAtCursor(bodyInput, mention);
      commentEditor ? commentEditor.focus() : bodyInput?.focus?.();
    });

    if(likeBtn){
      likeBtn.addEventListener('click', async ()=>{
        if(!likeSupported){
          toast('åŠŸèƒ½æœªå¯ç”¨', 'è¯·å…ˆè¿è¡Œæœ€æ–° Supabase SQLï¼ˆåˆ›å»º case_likes è¡¨ï¼‰ã€‚', 'err');
          return;
        }
        if(isConfigured()){
          const next = encodeURIComponent(location.pathname + location.search);
          const ok = await ensureAuthed(`login.html?next=${next}`);
          if(!ok) return;
        }
        if(!currentUser || !currentCase){ return; }

        const origLiked = liked;
        const origCount = Number(likeCountEl?.textContent || 0) || 0;

        // optimistic UI
        const nextLiked = !origLiked;
        const nextCount = Math.max(origCount + (nextLiked ? 1 : -1), 0);
        liked = nextLiked;
        if(likeCountEl) likeCountEl.textContent = String(nextCount);
        updateLikeBtn();

        likeBtn.disabled = true;
        try{
          if(nextLiked){
            const row = { case_id: currentCase.id, user_id: currentUser.id };
            let res = await supabase
              .from('case_likes')
              .upsert(row, { onConflict: 'case_id,user_id', ignoreDuplicates: true });
            if(res?.error){
              // Fallback for older client versions
              res = await supabase.from('case_likes').insert(row);
              if(res?.error){
                const msg = String(res.error.message || res.error);
                if(!(/duplicate key/i.test(msg) || String(res.error.code || '') === '23505')){
                  throw res.error;
                }
              }
            }
          }else{
            const { error } = await supabase
              .from('case_likes')
              .delete()
              .eq('case_id', currentCase.id)
              .eq('user_id', currentUser.id);
            if(error) throw error;
          }

          // Sync like_count from DB (trigger-updated)
          try{
            const { data } = await supabase
              .from('cases')
              .select('like_count')
              .eq('id', currentCase.id)
              .maybeSingle();
            if(data && typeof data.like_count !== 'undefined'){
              const n = Math.max(0, Number(data.like_count || 0));
              if(likeCountEl) likeCountEl.textContent = String(n);
            }
          }catch(_e){}
        }catch(err){
          // rollback UI
          liked = origLiked;
          if(likeCountEl) likeCountEl.textContent = String(Math.max(origCount, 0));
          updateLikeBtn();

          const msg = err?.message || String(err);
          if(/case_likes/i.test(msg) && /does not exist|relation/i.test(msg)){
            toast('ç‚¹èµåŠŸèƒ½æœªåˆå§‹åŒ–', 'è¯·åœ¨ Supabase SQL Editor è¿è¡Œæœ€æ–°ç‰ˆ SUPABASE_SETUP.sqlï¼Œç„¶å Settings â†’ API ç‚¹å‡» â€œReload schemaâ€ã€‚', 'err');
          }else{
            toast('æ“ä½œå¤±è´¥', msg, 'err');
          }
        }finally{
          likeBtn.disabled = false;
        }
      });
    }


    // æ”¶è— / å–æ¶ˆæ”¶è—
    if(favBtn){
      favBtn.addEventListener('click', async ()=>{
        if(!isConfigured()){
          toast('æœªé…ç½®', 'è¯·å…ˆåœ¨ config.js å¡«å…¥ Supabase ä¿¡æ¯ã€‚', 'err');
          return;
        }

        // Require login for favorites
        if(!currentUser){
          const q = new URLSearchParams(location.search);
          const caseId = q.get('id') || '';
          const next = `case.html?id=${caseId}`;
          const ok = await ensureAuthed(`login.html?next=${encodeURIComponent(next)}`);
          if(!ok) return;
        }
        if(!currentUser || !currentCase) return;

        const origFaved = faved;
        const nextFaved = !origFaved;

        // Optimistic UI
        faved = nextFaved;
        updateFavBtn();

        favBtn.disabled = true;
        try{
          if(nextFaved){
            const row = { case_id: currentCase.id, user_id: currentUser.id };
            const res = await supabase
              .from('case_favorites')
              .upsert(row, { onConflict: 'case_id,user_id', ignoreDuplicates: true });
            if(res?.error){
              // Fallback for older client versions
              const r2 = await supabase.from('case_favorites').insert(row);
              if(r2?.error){
                const msg = String(r2.error.message || r2.error);
                if(!(/duplicate key/i.test(msg) || String(r2.error.code || '') === '23505')){
                  throw r2.error;
                }
              }
            }
          }else{
            const { error } = await supabase
              .from('case_favorites')
              .delete()
              .eq('case_id', currentCase.id)
              .eq('user_id', currentUser.id);
            if(error) throw error;
          }
        }catch(err){
          // Rollback UI
          faved = origFaved;
          updateFavBtn();

          const msg = String(err?.message || err || '');
          // Supabase/PostgREST åœ¨åˆšå»ºè¡¨ä½†æœª Reload schema æ—¶ï¼Œå¸¸è§æŠ¥é”™ï¼š"schema cache" / "could not find"ã€‚
          if(/case_favorites/i.test(msg) && /(does not exist|relation|schema cache|could not find|not find)/i.test(msg)){
            toast('æ”¶è—åŠŸèƒ½æœªåˆå§‹åŒ–', 'è¯·åœ¨ Supabase SQL Editor è¿è¡Œ MIGRATION_20260110_FAVORITES.sqlï¼Œç„¶å Settings â†’ API ç‚¹å‡» â€œReload schemaâ€ã€‚', 'err');
          }else{
            toast('æ“ä½œå¤±è´¥', msg, 'err');
          }
        }finally{
          favBtn.disabled = false;
        }
      });
    }

    loadCase();
  </script>
  <script type="module" src="app.js?v=20260128_030"></script>
</body>
</html>
